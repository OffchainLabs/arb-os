//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type Account;
import type EvmCallFrame;
import type EvmLogs;
import type ByteArray;
import type MarshalledBytes;
import type Queue;

import impure func evmCallStack_topFrame() -> option<EvmCallFrame>;
import impure func evmCallStack_oldestCallFrame() -> option<EvmCallFrame>;
import impure func evmCallStack_getTopFrameReturnData() -> option<ByteArray>;
import impure func evmCallStack_getTopFrameMemoryOrDie() -> ByteArray;
import impure func evmCallStack_setTopFrameMemory(mem: ByteArray) -> bool;
import impure func evmCallStack_setTopFrameStorageCell(offset: uint, val: uint) -> option<()>;
import impure func evmCallStack_addEvmLogToCurrent(log: any) -> option<()>;
import impure func evmCallStack_selfDestructCurrentAccount(owner: address);
import impure func evmCallStack_doCall(
    kind: uint,
    gas: uint,
    calleeAddr: address,
    balance: uint,
    argsOffset: uint,
    argsLength: uint,
    retOffset: uint,
    retLength: uint,
    resumeCodePoint: func(),
) -> option<()>;
import impure func evmCallStack_returnFromCall(
    success: bool,
    returnOffset: uint,
    returnLength: uint
) -> option<()>;

import func evmCallFrame_runningAsAccount(frame: EvmCallFrame) -> Account;
import func evmCallFrame_runningCodeFromAccount(frame: EvmCallFrame) -> Account;
import func evmCallFrame_getAccount(frame: EvmCallFrame, addr: address) -> Account;
import func evmCallFrame_getCaller(frame: EvmCallFrame) -> address;
import func evmCallFrame_getMemory(frame: EvmCallFrame) -> ByteArray;
import func evmCallFrame_getResumeCodePoint(frame: EvmCallFrame) -> option<func()>;
import func evmCallFrame_getCallvalue(frame: EvmCallFrame) -> uint;
import func evmCallFrame_getCalldata(frame: EvmCallFrame) -> ByteArray;
import func evmCallFrame_getEvmLogs(frame: EvmCallFrame) -> EvmLogs;
import func evmCallFrame_getSelfDestructQueue(frame: EvmCallFrame) -> Queue;

import func account_getAddress(acct: Account) -> address;
import func account_getCodeSize(acct: Account) -> uint;
import func account_getBalance(acct: Account) -> uint;
import func account_getCode(acct: Account) -> option<ByteArray>;
import func account_getStorageCell(acct: Account, offset: uint) -> option<uint>;
import func account_getEvmJumpTable(acct: Account) -> option<map<uint, func()>>;

import impure func inbox_currentTimestamp() -> uint;
import impure func inbox_currentBlockNumber() -> uint;

import func evmlogs_empty() -> EvmLogs;

import func bytearray_new(capacity: uint, autoExpand: bool) -> ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, offset: uint) -> option<uint>;
import func bytearray_setByte(ba: ByteArray, offset: uint, val: uint) -> option<ByteArray>;
import func bytearray_get256(ba: ByteArray, offset: uint) -> option<uint>;
import func bytearray_set256(ba: ByteArray, offset: uint, val: uint) -> option<ByteArray>;
import func bytearray_extract(ba: ByteArray, offset: uint, nbytes: uint) -> option<ByteArray>;
import func bytearray_copy(from: ByteArray, fromOffset: uint, to: ByteArray, toOffset: uint, nbytes: uint) -> option<ByteArray>;
import func bytearray_marshalFull(from: ByteArray) -> MarshalledBytes;

import func queue_isEmpty(q: Queue) -> bool;
import func queue_get(q: Queue) -> (Queue, any);

import func keccak256(array: ByteArray, offset: uint, nbytes: uint) -> option<bytes32>;


public impure func evmOp_stop() {
    evmOp_return(0, 0);
}

public impure func evmOp_sha3(baseMemAddr: uint, nbytes: uint) -> bytes32 {
    if let Some(h) = keccak256(evmCallStack_getTopFrameMemoryOrDie(), baseMemAddr, nbytes) {
        return h;
    } else {
        evm_runtimePanic();
        return bytes32(0);
    }
}

public impure func evmOp_address() -> address {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return account_getAddress(evmCallFrame_runningAsAccount(topFrame));
    }

    evm_runtimePanic();
    return address(0);
}

public impure func evmOp_balance(addr: address) -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return account_getBalance(
            evmCallFrame_getAccount(topFrame, addr)
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}
    
public impure func evmOp_origin() -> address {
    if let Some(oldie) = evmCallStack_oldestCallFrame() {
        return account_getAddress(evmCallFrame_runningAsAccount(oldie));
    }

    evm_runtimePanic();
    return address(0);
}
    
public impure func evmOp_caller() -> address {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return evmCallFrame_getCaller(topFrame);
    }

    evm_runtimePanic();
    return address(0);
}

public impure func evmOp_callvalue() -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return evmCallFrame_getCallvalue(topFrame);
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public impure func evmOp_calldataload(offset: uint) -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        if let Some(val) = bytearray_get256(evmCallFrame_getCalldata(topFrame), offset) {
            return val;
        }
    }

    evm_runtimePanic();
    return 0;
}

public impure func evmOp_calldatasize() -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return bytearray_size(evmCallFrame_getCalldata(topFrame));
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public impure func evmOp_calldatacopy(memAddr: uint, calldataOffset: uint, nbytes: uint) {
    if let Some(topFrame) = evmCallStack_topFrame() {
        if let Some(newMemory) = bytearray_copy(
            evmCallFrame_getCalldata(topFrame),
            calldataOffset,
            evmCallFrame_getMemory(topFrame),
            memAddr,
            nbytes
        ) {
            if (evmCallStack_setTopFrameMemory(newMemory,)) {
                return;
            }
        }
    }

    evm_runtimePanic();
}

public impure func evmOp_codesize() -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return account_getCodeSize(
            evmCallFrame_runningCodeFromAccount(topFrame)
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public impure func evmOp_codecopy(memAddr: uint, codeOffset: uint, nbytes: uint) {
    if let Some(topFrame) = evmCallStack_topFrame() {
        let memory = evmCallFrame_getMemory(topFrame);
        if let Some(code) = account_getCode(
            evmCallFrame_runningCodeFromAccount(topFrame)
        ) {
            if let Some(updatedMemory) = bytearray_copy(
                code,
                codeOffset,
                memory,
                memAddr,
                nbytes
            ) {
                if (evmCallStack_setTopFrameMemory(updatedMemory,)) {
                    return;
                }
            }
        }
    }

    evm_runtimePanic();
}

public impure func evmOp_extcodesize(addr: address) -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return account_getCodeSize(
            evmCallFrame_getAccount(topFrame, addr)
        );
    }

    evm_runtimePanic();
    return 0;
}

public impure func evmOp_extcodecopy(addr: address, memAddr: uint, codeOffset: uint, nbytes: uint) {
    if let Some(topFrame) = evmCallStack_topFrame() {
        let memory = evmCallFrame_getMemory(topFrame);
        if let Some(code) = account_getCode(
            evmCallFrame_getAccount(topFrame, addr)
        ) {
            if let Some(updatedMemory) = bytearray_copy(
                code,
                codeOffset,
                memory,
                memAddr,
                nbytes
            ) {
                if (evmCallStack_setTopFrameMemory(updatedMemory,)) {
                    return;
                }
            }
        }
    }

    evm_runtimePanic();
}

public impure func evmOp_returndatasize() -> uint {
    if let Some(returnData) = evmCallStack_getTopFrameReturnData() {
        return bytearray_size(returnData);
    }

    evm_runtimePanic();
    return 0;
}

public impure func evmOp_returndatacopy(memAddr: uint, dataOffset: uint, nbytes: uint) {
    if let Some(returnData) = evmCallStack_getTopFrameReturnData() {
        let memory = evmCallStack_getTopFrameMemoryOrDie();
        if let Some(updatedMemory) = bytearray_copy(
            returnData,
            0,
            memory,
            dataOffset,
            nbytes
        ) {
            if (evmCallStack_setTopFrameMemory(updatedMemory,)) {
               return;
            }
        }
    }

    evm_runtimePanic();
}

public impure func evmOp_timestamp() -> uint {
    return inbox_currentTimestamp();
}

public impure func evmOp_number() -> uint {
    return inbox_currentBlockNumber();
}

public impure func evmOp_mload(memAddr: uint) -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        if let Some(val) = bytearray_get256(
            evmCallFrame_getMemory(topFrame),
            memAddr
        ) {
            return val;
        }
    }

    evm_runtimePanic();
    return 0;
}

public impure func evmOp_mstore(memAddr: uint, value: uint) {
    if let Some(topFrame) = evmCallStack_topFrame() {
        if let Some(memory) = bytearray_set256(
            evmCallFrame_getMemory(topFrame),
            memAddr,
            value
        ) {
            if (evmCallStack_setTopFrameMemory(memory)) {
                return;
            }
        }
    }

    evm_runtimePanic();
}

public impure func evmOp_mstore8(memAddr: uint, value:uint) {
    if let Some(topFrame) = evmCallStack_topFrame() {
        if let Some(memory) = bytearray_setByte(
            evmCallFrame_getMemory(topFrame),
            memAddr,
            value
        ) {
            if (evmCallStack_setTopFrameMemory(memory)) {
                return;
            }
        }
    }

    evm_runtimePanic();
}
    
public impure func evmOp_sload(storageAddr: uint) -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        if let Some(val) = account_getStorageCell(
            evmCallFrame_runningAsAccount(topFrame),
            storageAddr
        ) {
            return val;
        }
    }

    evm_runtimePanic();
    return 0;
}

public impure func evmOp_sstore(storageAddr: uint, value: uint) {
    if let Some(topFrame) = evmCallStack_topFrame() {
        if let Some(_) = evmCallStack_setTopFrameStorageCell(
            storageAddr,
            value
        ) {
            return;
        }
    }

    evm_runtimePanic();
}
    
public impure func evmOp_getjumpaddr(evm_pc: uint) -> func() {
    if let Some(topFrame) = evmCallStack_topFrame() {
        if let Some(jumpTable) = account_getEvmJumpTable(
            evmCallFrame_runningCodeFromAccount(topFrame)
        ) {
            if let Some(codept) = jumpTable[evm_pc] {
                return codept;
            } else {
                evm_error();   // EVM code tried to jump to a forbidden code address
                panic;
            }
        }
    }

    evm_runtimePanic();
    panic;
}

public impure func evmOp_msize() -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return bytearray_size(
            evmCallFrame_getMemory(topFrame)
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public impure func evmOp_log0(
    memAddr: uint, 
    nbytes: uint
) {
    asm(999,) { debugprint };
    if let Some(data) = bytearray_extract(
        evmCallStack_getTopFrameMemoryOrDie(),
        memAddr,
        nbytes
    ) {
        if (evmCallStack_addEvmLogToCurrent(
            (
                address(0),  // addEvmLogToCurrent will fill this in
                bytearray_marshalFull(data),
            )
        ) == Some(()) ) {
            return;
        }
    }

    evm_runtimePanic();
    panic;
}

public impure func evmOp_log1(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint
) {
    asm(999,) { debugprint };
    if let Some(data) = bytearray_extract(
        evmCallStack_getTopFrameMemoryOrDie(),
        memAddr,
        nbytes
    ) {
        if (evmCallStack_addEvmLogToCurrent(
            (
                address(0),  // addEvmLogToCurrent will fill this in
                bytearray_marshalFull(data),
                topic0
            )
        ) == Some(()) ) {
            return;
        }
    }

    evm_runtimePanic();
    panic;
}

public impure func evmOp_log2(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint,
    topic1: uint,
) {
    asm(999,) { debugprint };
    if let Some(data) = bytearray_extract(
        evmCallStack_getTopFrameMemoryOrDie(),
        memAddr,
        nbytes
    ) {
        asm(9991,) { debugprint };
        if (evmCallStack_addEvmLogToCurrent(
            (
                address(0),  // addEvmLogToCurrent will fill this in
                bytearray_marshalFull(data),
                topic0,
                topic1
            )
        ) == Some(()) ) {
            asm(9992,) { debugprint };
            return;
        }
    }

    asm(9993,) { debugprint };
    evm_runtimePanic();
    panic;
}

public impure func evmOp_log3(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint,
    topic1: uint,
    topic2: uint,
) {
    asm(999,) { debugprint };
    if let Some(data) = bytearray_extract(
        evmCallStack_getTopFrameMemoryOrDie(),
        memAddr,
        nbytes
    ) {
        if (evmCallStack_addEvmLogToCurrent(
            (
                address(0),  // addEvmLogToCurrent will fill this in
                bytearray_marshalFull(data),
                topic0,
                topic1,
                topic2
            )
        ) == Some(()) ) {
            return;
        }
    }

    evm_runtimePanic();
    panic;
}

public impure func evmOp_log4(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint,
    topic1: uint,
    topic2: uint,
    topic3: uint,
) {
    asm(999,) { debugprint };
    if let Some(data) = bytearray_extract(
        evmCallStack_getTopFrameMemoryOrDie(),
        memAddr,
        nbytes
    ) {
        if (evmCallStack_addEvmLogToCurrent(
            (
                address(0),  // addEvmLogToCurrent will fill this in
                bytearray_marshalFull(data),
                topic0,
                topic1,
                topic2,
                topic3
            )
        ) == Some(()) ) {
            return;
        }
    }

    evm_runtimePanic();
    panic;
}

public func evmOp_sloadbytes() {
    // believe this is a non-standard opcode
    evm_notYetImplemented(14,);
}

public func evmOp_sstorebytes() {
    // believe this is a non-standard opcode
    evm_notYetImplemented(15,);
}

public func evmOp_ssize() {
    // believe this is a non-standard opcode
    evm_notYetImplemented(16,);
}

public impure func evmOp_call(
    gas: uint,
    callee: address,
    balance: uint,
    argsOffset: uint,
    argsLength: uint,
    retOffset: uint,
    retLength: uint
) -> bool {
    let resumeCodePoint = asm() func() {  // get return address of our caller
        auxpop
        auxpop
        dup0
        swap2
        swap1
        auxpush
        auxpush
    };
    let res = evmCallStack_doCall(  // after call, this will throw control back to our caller
        0,
        gas,
        callee,
        balance,
        argsOffset,
        argsLength,
        retOffset,
        retLength,
        resumeCodePoint
    );
    if (res == None<()>) {
        return false;  // couldn't make a call, return failure
    } else {
        // should never get here -- control should have been thrown elsewhere
        panic;
    }
}

public impure func evmOp_callcode(
    gas: uint,
    callee: address,
    balance: uint,
    argsOffset: uint,
    argsLength: uint,
    retOffset: uint,
    retLength: uint
) -> bool {
    let resumeCodePoint = asm() func() {  // get return address of our caller
        auxpop
        auxpop
        dup0
        swap2
        swap1
        auxpush
        auxpush
    };
    let res = evmCallStack_doCall(  // after call, this will throw control back to our caller
        1,
        gas,
        callee,
        balance,
        argsOffset,
        argsLength,
        retOffset,
        retLength,
        resumeCodePoint
    );
    if (res == None<()>) {
        return false;  // couldn't make a call, return failure
    } else {
        // should never get here -- control should have been thrown elsewhere
        panic;
    }
}

public impure func evmOp_delegatecall(
    gas: uint,
    callee: address,
    argsOffset: uint,
    argsLength: uint,
    retOffset: uint,
    retLength: uint
) -> bool {
     let resumeCodePoint = asm() func() {  // get return address of our caller
         auxpop
         auxpop
         dup0
         swap2
         swap1
         auxpush
         auxpush
     };
     let res = evmCallStack_doCall(  // after call, this will throw control back to our caller
         2,
         gas,
         callee,
         0,  // balance is zero for a delegatecall
         argsOffset,
         argsLength,
         retOffset,
         retLength,
         resumeCodePoint
     );
     if (res == None<()>) {
         return false;  // couldn't make a call, return failure
     } else {
         // should never get here -- control should have been thrown elsewhere
         panic;
     }}

public impure func evmOp_staticcall(
    gas: uint,
    callee: address,
    argsOffset: uint,
    argsLength: uint,
    retOffset: uint,
    retLength: uint
) -> bool {
    let resumeCodePoint = asm() func() {  // get return address of our caller
        auxpop
        auxpop
        dup0
        swap2
        swap1
        auxpush
        auxpush
    };
    let res = evmCallStack_doCall(  // after call, this will throw control back to our caller
        3,
        gas,
        callee,
        0,  // balance is zero for a staticcall
        argsOffset,
        argsLength,
        retOffset,
        retLength,
        resumeCodePoint
    );
    if (res == None<()>) {
        return false;  // couldn't make a call, return failure
    } else {
        // should never get here -- control should have been thrown elsewhere
        panic;
    }
}

public impure func evmOp_revert(memOffset: uint, memNbytes: uint) {
    let _ = evmCallStack_returnFromCall(false, memOffset, memNbytes);

    evm_runtimePanic();
}

public impure func evmOp_return(memOffset: uint, memNbytes: uint) {
    let _ = evmCallStack_returnFromCall(true, memOffset, memNbytes);

    evm_runtimePanic();
}

public func evmOp_txexecgas() {
    // believe this is a non-standard opcode
    evm_notYetImplemented(23,);
}

public impure func evmOp_selfdestruct(owner: address) {
    evmCallStack_selfDestructCurrentAccount(owner,);
}

public impure func evmOp_create(value: uint, offset: uint, length: uint) -> address {
    asm((27, length),) { debugprint };
    evm_notYetImplemented(66,);
    panic;
}

impure func evm_error() {
    // This should be called when EVM code has generated an EVM error.
    evmOp_revert(0, 0);  // should never return
    panic;
}

func evm_runtimePanic() {
    // This should be called when something that "shouldn't ever happen" has occurred.
    // It should only be called if something has gone wrong in the trusted code.
    // If untrusted code has encountered an error, that will be handled elsewhere.
    panic;
}

func evm_notYetImplemented(op: uint) {
    panic;
}
