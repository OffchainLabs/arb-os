//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type MessageFromL1;

import impure func errorHandler_init();
import impure func initKeccakConstants();
import impure func gasAccounting_init();
import impure func inbox_init();
import impure func accountStore_init();

import impure func inbox_get() -> MessageFromL1;
import impure func handleMessageFromL1(msg: MessageFromL1) -> option<()>;


impure func main() {
    errorHandler_init();
    initKeccakConstants();
    gasAccounting_init();
    inbox_init();
    accountStore_init();
    
    mainRunLoop();
}

public impure func mainRunLoop() {
    loop {
        let msg = inbox_get();
        if (None<()> == handleMessageFromL1(msg,)) {
            panic;   //BUGBUG: just used for debugging
        }
    }
    panic;  // should never be reached
}

public impure func cleanUpAndJumpToRunLoop() {
    // When this is called, there might be unwanted junk in the stack and auxstack
    // This function will discard all of that stuff and then jump to mainRunLoop

    // discard everything from the auxstack, except the current callframe (which is on top)
    // keep the callframe on top of the auxstack (except during asm blocks) because the code generator might use it
    while ( ! asm() bool { auxpop auxstackempty swap1 auxpush }) {
        asm() {
            auxpop
            auxpop
            pop
            auxpush
        };
    }

    // discard everything on the stack
    while ( ! asm() bool { stackempty }) {
        asm() { pop };
    }

    // discard our callframe, push a fake return address, and jump to mainRunLoop
    // mainRunLoop will think somebody called it normally
    asm(mainRunLoop,) {
        auxpop
        pop
        [0] swap1  // bogus return address, which mainRunLoop will save in its callframe but will never use
        jump
    };

    panic; // should never be reached
}