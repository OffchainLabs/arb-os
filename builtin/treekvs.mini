//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

type TreeKvsTriple = struct {
    reducedKey: uint,
    key: any,
    value: any
}

type TreeKvsCell = struct {
    triple: option<TreeKvsTriple>,
    children: [8]any   // actually [8]TreeKvs but compiler doesn't suppport recursive types
}

type TreeKvs = option<TreeKvsCell>


public func treekvs_new() -> TreeKvs {
    return None<TreeKvsCell>;
}

public func treekvs_get(kvs: TreeKvs, key: any) -> option<any> {
    let reducedKey = uint(hash(key));
    loop {
        let cell = kvs?;
        if let Some(triple) = cell.triple {
            if (reducedKey == triple.reducedKey) {
                return Some(triple.value);
            }
        }
        kvs = unsafecast<TreeKvs>(cell.children[reducedKey % 8]);
        reducedKey = reducedKey / 8;
    }
}

public func treekvs_hasKey(kvs: TreeKvs, key: any) -> bool {
    return treekvs_get(kvs, key) != None<any>;
}

public func treekvs_set(kvs: TreeKvs, key: any, value: any) -> TreeKvs {
    if let Some(newKvs) = treekvs_set2(
        kvs,
        uint(hash(key)),
        key,
        value
    ) {
        return newKvs;
    } else {
        return kvs;
    }
}

func treekvs_set2(
    kvs: TreeKvs,
    reducedKey: uint,
    key: any,
    value: any
) -> option<TreeKvs> {
    // Returns Some if the structure changed, None if it didn't.
    if let Some(cell) = kvs {
        if let Some(triple) = cell.triple {
            if (triple.reducedKey == reducedKey) {
                return Some(Some(
                    cell with {
                        triple: Some(triple with { value: value })
                    }
                ));
            }
            let slot = reducedKey % 8;
            return Some(Some(
                cell with {
                    children: cell.children with {
                        [slot] = treekvs_set2(
                            unsafecast<TreeKvs>(cell.children[slot]),
                            reducedKey / 8,
                            key,
                            value
                        )?
                    }
                }
            ));
        } else {
            return Some(Some(
                cell with {
                    triple: Some(struct {
                        reducedKey: reducedKey,
                        key: key,
                        value: value
                    })
                }
            ));
        }
    } else {
        return Some(Some(
            struct {
                triple: Some(struct {
                    reducedKey: reducedKey,
                    key: key,
                    value: value
                }),
                children: newfixedarray(8, None<TreeKvsCell>)
            }
        ));
    }
}

public func treekvs_delete(kvs: TreeKvs, key: any) -> TreeKvs {
    if let Some(newKvs) = treekvs_delete2(kvs, uint(hash(key))) {
        return newKvs;
    } else {
        return kvs;
    }
}

func treekvs_delete2(kvs: TreeKvs, reducedKey: uint) -> option<TreeKvs> {
    let cell = kvs?;
    if let Some(triple) = cell.triple {
        if (triple.reducedKey == reducedKey) {
            return Some(Some(cell with { triple: None<TreeKvsTriple> }));
        }
    }
    let slot = reducedKey % 8;
    return Some(Some(
        cell with {
            children: cell.children with {
                [slot] = treekvs_delete2(
                    unsafecast<TreeKvs>(cell.children[slot]),
                    reducedKey / 8,
                )?
            }
        }
    ));
}

public func treekvs_forall(
    kvs: TreeKvs,
    callback: func(any, any, any) -> any,
    state: any
) -> any {
    if let Some(cell) = kvs {
        if let Some(triple) = cell.triple {
            state = callback(triple.key, triple.value, state);
        }
        let i = 0;
        while (i < 8) {
            state = treekvs_forall(
                unsafecast<TreeKvs>(cell.children[i]),
                callback,
                state
            );
            i = i+1;
        }
    }

    return state;
}
