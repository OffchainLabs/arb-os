//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// This implements a key-value store.
// Uses of the map data structure in Mini compile into calls to this package.
// So please consult with the team before changing APIs or semantics of any of this.

// These functions can also be imported and called directly by Mini programs.

// Normal Mini code won't ever "reach inside" a map to disturb the integrity of this
// data structure. But note that use of unsafe language features could lead to structural
// damage to the internals of a map, leading to erroneous results or even a panic.


type TreeKvsTriple = struct {  // This struct stores one item in the KVS.
    reducedKey: uint,   // hash of the item's key, divided by 8 for each level we descend in the tree
    key: any,           // item's key
    value: any          // item's value
}

type TreeKvsCell = struct {   // The KVS is represented as a tree of these.
    triple: option<TreeKvsTriple>,
    children: [8]any    // actually [8]TreeKvs but compiler doesn't support recursive types
}

type TreeKvs = option<TreeKvsCell>   // will be None if tree is empty


public func builtin_kvsNew() -> TreeKvs {
    return None<TreeKvsCell>;
}

public func builtin_kvsGet(kvs: TreeKvs, key: any) -> option<any> {
    let reducedKey = uint(hash(key));
    loop {
        let cell = kvs?;
        if let Some(triple) = cell.triple {
            if (reducedKey == triple.reducedKey) {
                return Some(triple.value);
            }
        }
        kvs = unsafecast<TreeKvs>(cell.children[reducedKey % 8]);
        reducedKey = reducedKey / 8;
    }
}

public func builtin_kvsHasKey(kvs: TreeKvs, key: any) -> bool {
    return builtin_kvsGet(kvs, key) != None<any>;
}

public func builtin_kvsSet(kvs: TreeKvs, key: any, value: any) -> TreeKvs {
    if let Some(newKvs) = builtin_kvsSet2(
        kvs,
        uint(hash(key)),
        key,
        value
    ) {
        return newKvs;
    } else {
        return kvs;
    }
}

func builtin_kvsSet2(
    kvs: TreeKvs,
    reducedKey: uint,
    key: any,
    value: any
) -> option<TreeKvs> {
    // Update a KVS by setting a key/value pair.
    // This returns Some(updatedKvs) if the structure changed, None if it didn't.
    if let Some(cell) = kvs {
        if let Some(triple) = cell.triple {
            if (triple.reducedKey == reducedKey) {
                // Found a cell containing the same key. Update the value.
                return Some(Some(
                    cell with {
                        triple: Some(triple with { value: value })
                    }
                ));
            } else {
                // Didn't find a match here, descend on level in the tree, recursively.
                let slot = reducedKey % 8;
                return Some(Some(
                    cell with {
                        children: cell.children with {
                            [slot] = builtin_kvsSet2(
                                unsafecast<TreeKvs>(cell.children[slot]),
                                reducedKey / 8,
                                key,
                                value
                            )?
                        }
                    }
                ));
            }
        } else {
            // This cell doesn't have a triple, so insert our new item here.
            // BUGBUG: Need to deal with the case where a matching key exists in some child of this cell.
            return Some(Some(
                cell with {
                    triple: Some(struct {
                        reducedKey: reducedKey,
                        key: key,
                        value: value
                    })
                }
            ));
        }
    } else {
        // There was nothing here, so allocate an empty cell and add this item to it.
        return Some(Some(
            struct {
                triple: Some(struct {
                    reducedKey: reducedKey,
                    key: key,
                    value: value
                }),
                children: newfixedarray(8, None<TreeKvsCell>)
            }
        ));
    }
}

public func builtin_kvsDelete(kvs: TreeKvs, key: any) -> TreeKvs {
    if let Some(newKvs) = builtin_kvsDelete2(kvs, uint(hash(key))) {
        return newKvs;
    } else {
        return kvs;
    }
}

func builtin_kvsDelete2(kvs: TreeKvs, reducedKey: uint) -> option<TreeKvs> {
    // Delete a key.
    // Returns Some(updatedKvs) is anything changed, None otherwise.
    let cell = kvs?;
    if let Some(triple) = cell.triple {
        if (triple.reducedKey == reducedKey) {
            // Found a matching item. Delete it and return.
            return Some(Some(cell with { triple: None<TreeKvsTriple> }));
        }
    }

    // Didn't find a match here, decend the tree recursively.
    let slot = reducedKey % 8;
    return Some(Some(
        cell with {
            children: cell.children with {
                [slot] = builtin_kvsDelete2(
                    unsafecast<TreeKvs>(cell.children[slot]),
                    reducedKey / 8,
                )?
            }
        }
    ));
}

public func builtin_kvsForall(
    kvs: TreeKvs,
    callback: func(any, any, any) -> any,
    state: any  // initial value for state
) -> any {
    // Visit every item in the KVS, calling callback on each one.
    // newState = callback(thisItem.key, thisItem.value, oldState)
    // Return the final state after visiting all items.
    if let Some(cell) = kvs {
        if let Some(triple) = cell.triple {
            state = callback(triple.key, triple.value, state);
        }
        let i = 0;
        while (i < 8) {
            state = builtin_kvsForall(
                unsafecast<TreeKvs>(cell.children[i]),
                callback,
                state
            );
            i = i+1;
        }
    }

    return state;
}
