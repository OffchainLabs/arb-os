//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type TreeKvs;

import func treekvs_new() -> TreeKvs;
import func treekvs_get(kvs: TreeKvs, key: bytes32) -> any;
import func treekvs_set(kvs: TreeKvs, key: bytes32, value: any) -> TreeKvs;
import func treekvs_delete(kvs: TreeKvs, key: bytes32) -> TreeKvs;
import func treekvs_forall(kvs: TreeKvs, cb: func(bytes32, any, any) -> any, initState: any) -> any;

impure func main() {
	asm(tests(),) { log };
}

func tests() -> uint {
	let s = treekvs_new();
	if (treekvs_get(s, bytes32(17)) != None<any>) {
		return 1;
	}

	s = treekvs_new();
	s = treekvs_set(s, bytes32(42), 42);
	if (treekvs_get(s, bytes32(42)) != Some(unsafecast<any>(42))) {
		return 2;
	}

	s = treekvs_new();
	s = treekvs_set(s, bytes32(42), 43);
	s = treekvs_set(s, bytes32(55), 56);
	s = treekvs_set(s, bytes32(42), 99);
	if (treekvs_get(s, bytes32(42)) != Some(unsafecast<any>(99))) {
		return 3;
	}

	s = treekvs_new();
	s = treekvs_set(s, bytes32(42), 43);
	s = treekvs_set(s, bytes32(55), 56);
	s = treekvs_set(s, bytes32(42), 99);

	if (treekvs_get(s, bytes32(55)) != Some(unsafecast<any>(56))) {
		return 4;
	}

	s = treekvs_new();
	let i = 0;
	while (i < 41) {
		s = treekvs_set(s, bytes32(i), 1000+i);
		i = i+1;
	}
	if (treekvs_get(s, bytes32(17)) != Some(unsafecast<any>(1017))) {
		return 5;
	}

	s = treekvs_new();
	let i = 0;
	while (i < 27) {
		s = treekvs_set(s, bytes32(i), 1000+i);
		i = i+1;
	}
	s = treekvs_delete(s, bytes32(17));
	if (treekvs_get(s, bytes32(17)) != None<any>) {
		return 6;
	}

	s = treekvs_new();
	s = treekvs_set(s, bytes32(42), 43);
	s = treekvs_set(s, bytes32(55), 56);
	s = treekvs_set(s, bytes32(42), 99);
	if (treekvs_get(s, bytes32(42)) != Some(unsafecast<any>(99))) {
		return 7;
	}

	s = treekvs_new();
	s = treekvs_set(s, bytes32(42), 43);
	s = treekvs_set(s, bytes32(55), 56);
	s = treekvs_set(s, bytes32(42), 99);
	if (treekvs_get(s, bytes32(3)) != None<any>) {
		return 8;
	}

	s = treekvs_new();
	s = treekvs_set(s, bytes32(42), 43);
	s = treekvs_set(s, bytes32(55), 56);
	s = treekvs_set(s, bytes32(42), 99);
	let rawResult = treekvs_forall(s, sumForKvsIterator, 0);
	if (unsafecast<uint>(rawResult) != 155) {
		return 9;
	}

	return 0;
}

func isSome(x: option<any>) -> bool {
	if let Some(unused) = x {
		return true;
	} else {
		return false;
	}
}

func getSomeOr(x: option<any>, backupVal: any) -> any {
	if let Some(val) = x {
		return val;
	} else {
		return backupVal;
	}
}

func sumForKvsIterator(key: bytes32, value: any, state: any) -> any {
	return unsafecast<uint>(value) + unsafecast<uint>(state);
}