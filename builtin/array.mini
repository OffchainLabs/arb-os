//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

type block = [8]any

type array = struct {
	size: uint,  // This must be the first field--codegen relies on this.
	topstep: uint,
	contents: block,
}

func main() -> any {
	return builtin_arrayNew(13, null);
}

public func builtin_arrayNew(sz: uint, base_val: any) -> array {
	let chunk = 1;
	while (8*chunk < sz) {
		chunk = 8*chunk;
		base_val = newfixedarray(8, base_val);
	}
	return struct {
		size: sz,
		topstep: chunk,
		contents: unsafecast<block>(newfixedarray(8, base_val)),
	};
}

public func builtin_arrayGet(arr: array, index: uint) -> any {
	if (index >= arr.size) {
		panic;
	}
	let res = arr.contents;
	let chunk = arr.topstep;
	while (1 <= chunk) {
		res = unsafecast<block>(res[index/chunk]);
		index = index % chunk;
		chunk = chunk / 8;
	}
	return res;
}

public func builtin_arrayGetSafe(arr: array, index: uint) -> option<any> {
	if (index >= arr.size) {
		return None;
	}
	return Some(builtin_arrayGet(arr, index));
}

public func builtin_arrayGetConsecutive(arr: array, index: uint) -> (any, any) {
	// get two consecutive items at [index] and [index+1]
	if (index+1 >= arr.size) {
		panic;
	}
	if ((index % 8) == 7) {
		// leaves are not in same bottom-level block, do it the slow way
		return (builtin_arrayGet(arr, index), builtin_arrayGet(arr, index+1),);
	} else {
		let res = arr.contents;
		let chunk = arr.topstep;
		while (8 <= chunk) {
			res = unsafecast<block>(res[index/chunk]);
			index = index % chunk;
			chunk = chunk / 8;
		}
		return (res[index], res[index+1],);
	}
}

public func builtin_arrayGetConsecutiveSafe(arr: array, index: uint) -> option<(any, any)> {
	if (index+1 >= arr.size) {
		return None;
	}
	return Some(builtin_arrayGetConsecutive(arr, index));
}

public func builtin_arraySet(arr: array, index: uint, value: any) -> array {
	if (index >= arr.size) {
		panic;
	}
	return arr with { contents: arraySet2(arr.contents, arr.topstep, index, value) };
}

public func builtin_arraySetSafe(arr: array, index: uint, value:any) -> option<array> {
	if (index >= arr.size) {
		return None;
	}
	return Some(builtin_arraySet(arr, index, value));
}

func arraySet2(b: block, chunk: uint, index: uint, value: any) -> block {
	if (1 == chunk) {
		return b with {[index] = value};
	} else {
		return b with {[index/chunk] = arraySet2(
			unsafecast<block>(b[index/chunk]), 
			chunk/8, 
			index%chunk, 
			value
		)};
	}
}

public func builtin_arraySwap(a: array, index: uint, value: any) -> (array, any) {
	if (index >= a.size) {
		panic;
	}
	let sub = arraySwap2(a.contents, a.topstep, index, value);
	return (
		a with { contents: sub.bloc },
		sub.val,
	);
}

public func builtin_arraySwapSafe(a: array, index: uint, value: any) -> option<(array, any)> {
	if (index >= a.size) {
		return None;
	}
	let (aOut, valOut) = builtin_arraySwap(a, index, value);
	return Some((aOut, valOut));
}

type arraySwapSubResult = struct {
	bloc: block,
	val:  any,
}

func arraySwap2(b: block, chunk: uint, index: uint, value: any)  -> arraySwapSubResult {
	if (1 == chunk) {
		return struct {
			bloc: b with {[index] = value},
			val: b[index],
		};
	} else {
		let subIndex = index/chunk;
		let sub = arraySwap2(
			unsafecast<block>(b[subIndex]),
			chunk/8,
			index%chunk,
			value
		);
		return sub with { bloc: b with {[subIndex] = sub.bloc} };
	}
}

type opClosure = struct {
	f: func(any, any) -> (any, any),
	val: any,
}

public func builtin_arrayOp(a: array, index: uint, closure: opClosure) -> (array, any) {
	if (index >= a.size) {
		panic;
	}
	let sub = arrayOp2(a.contents, a.topstep, index, closure);
	return (
		a with { contents: sub.bloc },
		sub.val,
	);
}

public func builtin_arrayOpSafe(a: array, index: uint, closure: opClosure) -> option<(array, any)> {
	if (index >= a.size) {
		return None;
	}
	let (aOut, valOut) = builtin_arrayOp(a, index, closure);
	return Some((aOut, valOut));
}

func arrayOp2(b: block, chunk: uint, index: uint, closure: opClosure) -> arraySwapSubResult {
	if (1 == chunk) {
		let result = closure.f(closure.val, b[index]);
		return struct {
			bloc: b with {[index] = result.0},
			val: result.1,
		};
	} else {
		let subIndex = index/chunk;
		let sub = arrayOp2(
			unsafecast<block>(b[subIndex]),
			chunk/8,
			index%chunk,
			closure
		);
		return sub with { bloc: b with {[subIndex] = sub.bloc} };
	}
}

public func builtin_arrayOpConsecutive(
	a: array, 
	index: uint, 
	closure1: opClosure, 
	closure2: opClosure
) -> (array, any, any) { 
	//TODO: optimize the case where both items are in the same bottom-level block
	let (arr1, ret1,) = builtin_arrayOp(a, index, closure1);
	let (arr2, ret2,) = builtin_arrayOp(arr1, index+1, closure2);
	return (arr2, ret1, ret2,);
}

public func builtin_arrayOpConsecutiveSafe(
	a: array, 
	index: uint, 
	closure1: opClosure, 
	closure2: opClosure
) -> option<(array, any, any)> {
	let (arr1, ret1) = builtin_arrayOpSafe(a, index, closure1)?;
	let (arr2, ret2) = builtin_arrayOpSafe(arr1, index+1, closure2)?;
	return Some((arr2, ret1, ret2));
}

public func array_resize(a: array, newSize: uint, baseVal: any) -> array { 
	// TODO: make this more efficient by reusing more of the tree-structure of a
	let minSize = a.size;
	if (minSize > newSize) {
		minSize = newSize;
	}
	let ret = builtin_arrayNew(newSize, baseVal);
	let i = 0;
	while (i < minSize) {
		ret = builtin_arraySet(ret, i, builtin_arrayGet(a, i));
		i = i+1;
	}
	return ret;
}
