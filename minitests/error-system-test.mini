//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

const UsedConstant = 0x44444444444444444;
const DuplicateConstant = 0x88888888888888888;
const DuplicateConstant = 0x88888888888888888;
const UnusedConstant = 0x88888888888888888;

use std::random::random_new;
use std::random::random_new;
use std::random::RandomGenerator;
use std::random::RandomGenerator;

use std::queue::Queue;
use std::queue::queue_new;

use std::priorityq::PriorityQ;
use std::priorityq::priorityq_isEmpty;
use std::priorityq::priorityq_new;

use std::bytearray::ByteArray;
use std::outputbuffer::OutputBuffer;

type FixedPoint = struct {
   val: uint,
   shiftFactor: ByteArray,
};

func main(arg: option<RandomGenerator>) -> (option<RandomGenerator>, option<option<option<Queue> > >) {
    
    let a = struct {
        val: arg,
        array: None<OutputBuffer>,
    };
    
    let (_, __) = (check(shadow, write func(uint, uint, uint)), check(hop, func()));
    
    return (Some(random_new(bytes32(0))), Some(Some(Some(queue_new()))));
}

var unused_global: uint;
var used_global: uint;

#[bad_attribute, inline]
public func hop() {
    used_global = check(crazy(4, 8, check(true, bool), 4), uint);
    asm(used_global) { log };
}

write view func crazy(n: uint, unused_arg: uint, unused_arg2: bool, _intentional: uint) -> uint {
    
    let (x, y) = (4, 8);
    let y = { let ux = x + 4; ux };
    let z = {4};
    let w = {4};
    let v = x + x + 4;
    let u = 4;       // should not warn
    
    x = y + 4;       // should not warn
    x = x + 8;
    x = w + 8;
    x = w;
    
    if (true) { v = x; } else { v = x; } // shouldn't warn
    if (true) { v = u; } else { let v = u; }
    
    if (true) {
      z = 4;         // should not warn
      let z = 8;
      z = 4;
      x = z;
      z = 8;
    }
    
    let (x, y) = (8, xif (8 == 8) { y = 4; y + 4 } else { let y = 4; y + 4 });
    let (x, y) = (4, xif (4 == 4) { y = 4; y     } else { let y = 4; y     });
    
    let ret = z;
    let cond = 4;
    while (n > x * cond) {
        ret = ret*n;
        n = n-1;
        return ret * y;
        
        let loopy = 4;
        let unreachable_variable = xloop {
          return loopy;
          loopy = loopy - 8;
          loopy = 4;            // should not warn
        };
        
        let z = check({{{4}}}, uint);
        let (z, z) = (z, 8);
        
        let unreachable_variable = 8;
        unreachable_variable = 4;
        return unreachable_variable;
        
        cond = check(4, uint);    // is unreachable but still a valid assignment
    }
    return v;
    
    let _unused_on_purpose = const::UsedConstant + const::_ShouldNotBeUsed;
    let _unused_on_purpose = const::NonExistantConstant;
    
    let with_init = newfixedarray(8, 0);
    let (newSlotContents, returnValue) = check((1, 2), (uint, uint));
    let some_struct = struct {
        bloc: with_init with { [0] = newSlotContents },
        val: returnValue,
    };
    
    let x = asm() uint { };
    let y = asm() uint { };
    let some_option = Some(struct { x: check(x + 1, uint), y: y });
    
    let unreachable_variable = 4;
    return unreachable_variable;
}

write func shadow(shadow_arg: uint, bad_arg: uint, good_arg: uint) {    // everything with an 8 should warn
  
     if (true) {
       if (true) {
         let shadow_arg = 4;
         shadow_arg = shadow_arg + 8;
       } else {
         bad_arg = bad_arg;
         while (true) {
           if (true) {
             good_arg = good_arg + 4;
           } else {
             if (true) {
               bad_arg = 1;
             }
           }
         }
       }
     }
     
     let xx = 8;           // (*) One of these should warn
     let yy = 4;
     let zz = 4;
     
     if (true) {
       zz = 8 * zz;
     }
     
     if (true) {
        if (true) {
          yy = yy * 8;
          yy = 8;          // (**) One of these should warn
        } else {
          yy = 8;          // (**) One of these should warn
        }
        xx = 4;
        xx = 4 * xx * xx;
        xx = 8 * xx;       // (*) One of these should warn
     }
     
     let loopy = 4;
     while (true) {
        loopy = loopy + 4;
     }
     
     let last = true;
     while (last) {
       if (true) {
         
       } else {
         last = false;
       }
     }
     
     let declared = 4;
     if (true) {
       let declared = 4 * declared;
       declared = 8 * declared;
     }
     
     let shadowing_edge_case = 4;
     while (true) {
       let shadowing_edge_case = shadowing_edge_case * 8;
     }
     
     #[bad_attribute]
     let final = 4;
     { xif (final == 4) { let _ = final; } elseif (true) { final = 8; } };
     { xif (final == 4) { final = 8; } elseif (true) { let final = 8 * final; } };
}

view write func unused_function() {}
func recursive_function() { recursive_function(); }

public func implicit_exporter() -> view func() { return implicit_export; }
view func implicit_export() {}
