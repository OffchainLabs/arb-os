//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

type RandomGenerator = bytes32;

public func random_new(seed: bytes32) -> RandomGenerator {
    seed
}

public func random_refresh_seed(rand: RandomGenerator, refresh: bytes32) -> RandomGenerator {
    hash(rand, refresh)
}

public func random_next(rand: RandomGenerator) -> (bytes32, RandomGenerator) {
    (
        hash(bytes32(0), rand), 
        hash(bytes32(1), rand),
    )
}

public func random_nextMod(rand: RandomGenerator, modulus: uint) -> (uint, RandomGenerator) {
    if modulus == 0 {
        return (0, rand);
    }
    let limit = modulus * ((~0)/modulus);
    let (b, r) = random_next(rand);
    rand = r;
    while uint(b) >= limit {
        let (ub, r) = random_next(rand);
        b = ub;
        rand = r;
    }
    (uint(b) % modulus, rand)
}

public throw func randomly_permute_array(
    rand: RandomGenerator,
    arr: []any,
    offset: uint,
    num: uint
) -> ([]any, RandomGenerator) {
    while num > 1 {
        let (rb, gen) = random_next(rand);
        rand = gen;
        let i = uint(rb) % num;   // This isn't perfectly uniform, but difference is negligible for this use.
        arr = arr with { [offset+i] = arr[offset+num-1] }
                  with { [offset+num-1] = arr[offset+i] };
        num = num-1;
    }
    (arr, rand)
}
