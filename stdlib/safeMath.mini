//
// Copyright 2021, Offchain Labs, Inc. All rights reserved.
//

const BasisPointsForOne = 10000;

public throw func safeAdd(x: uint, y: uint) -> uint {
    let ret = x + y;
    if ret < x {
        error;
    }
    ret
}

public func trySafeAdd(x: uint, y: uint) -> option<uint> {
    let ret = x + y;
    if ret < x {
        None
    } else {
        Some(ret)
    }
}

public throw func safeSub(x: uint, y: uint) -> uint {
    if x < y {
        error;
    }
    x - y
}

public func trySafeSub(x: uint, y: uint) -> option<uint> {
    if x < y {
        None
    } else {
        Some(x - y)
    }
}

public throw func safeMul(x: uint, y: uint) -> uint {
    let ret = x * y;
    if (x != 0) && (y != (ret/x)) {
        error;
    }
    ret
}

public func trySafeMul(x: uint, y: uint) -> option<uint> {
    let ret = x * y;
    if (x != 0) && (y != (ret/x)) {
        None
    } else {
        Some(ret)
    }
}

public throw func safeToInt(x: uint) -> int {
    let ret = int(x);
    if ret < int(0) {
        error;
    }
    int(ret)
}

public throw func safeAddInt(x: int, y: int) -> int {
    let ret = x + y;
    if x > int(0) {
        if ret < y {
            error;
        }
    } else if x < int(0) {
        if ret > y {
            error;
        }
    }
    ret
}

public throw func safeSubInt(x: int, y: int) -> int {
    let ret = x - y;
    if y > int(0) {
        if ret > x {
            error;
        }
    } else if y < int(0) {
        if ret < x {
            error;
        }
    }
    ret
}

public func trySafeSubInt(x: int, y: int) -> option<int> {
    let ret = x - y;
    if y > int(0) {
        if ret > x {
            None
        } else {
            Some(ret)
        }
    } else if y < int(0) {
        if ret < x {
            None
        } else {
            Some(ret)
        }
    } else {
        Some(ret)
    }
}

public throw func safeMulInt(x: int, y: int) -> int {
    let ret = x * y;
    if (x != int(0)) && (y != (ret/x)) {
        error;
    }
    ret
}

public func trySafeMulInt(x: int, y: int) -> option<int> {
    let ret = x * y;
    if (x != int(0)) && (y != (ret/x)) {
        None
    } else {
        Some(ret)
    }
}

public throw func safeToUint(x: int) -> uint {
    if x < int(0) {
        error;
    }
    uint(x)
}

// This takes an argument, denominated in basis points, and returns
// exp(in) denominated in basis points.  This uses a Taylor series approximation, up to the x**4 term,
// centered at x==0.  The result is clamped to a constant if the input is greater than 2**64.
// The approximation error will about 5% when in == 2*BasisPointsForOne.  The result will be closer to
// BasisPointsForOne than the true exp function would be.
public func approxExpBasisPoints(in: int) -> uint {
    let (x, wasNegative) = if in < int(0) {
        (uint(-in), true)
    } else {
        (uint(in), false)
    };
    if x > (1<<64) {
        x = 1<<64;
    }
    let res = const::BasisPointsForOne + x / 4;
    res = const::BasisPointsForOne + res * x / (3 * const::BasisPointsForOne);
    res = const::BasisPointsForOne + res * x / (2 * const::BasisPointsForOne);
    res = const::BasisPointsForOne + res * x / const::BasisPointsForOne;
    if wasNegative { (const::BasisPointsForOne * const::BasisPointsForOne) / res } else { res }
}
