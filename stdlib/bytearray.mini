//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import func array_resize(a: []uint, newSize: uint, baseVal: uint) -> []uint;
import func builtin_arrayGet(a: []uint, index: uint) -> uint;
import func builtin_arrayGetConsecutive(a: []uint, index: uint) -> (uint, uint);
import func builtin_arrayOp(
    a: []uint, 
    index: uint, 
    closure: opClosure
) -> ([]uint, uint);
import func builtin_arrayOpConsecutive(
    a: []uint, 
    index: uint, 
    closure1: opClosure, 
    closure2: opClosure
    ) -> ([]uint, uint, uint);

type opClosure = struct {
	f: func((uint, uint), uint) -> (uint, uint),  // (closure.val, oldVal) -> (newVal, return)
	val: (uint, uint),
}

type ByteArray = struct { 
    size: uint,
    capacity: uint, 
    contents: []uint,
}

// bytearray_new makes a new ByteArray
// it will initially have size zero,
//        reads beyond the end will return zero,
//        size will expand to fit all writes,
//        and the capacity arg is a hint about how big it will get
public func bytearray_new(capacity: uint) -> ByteArray {
    let roundedUpCapacity = 8*32;
    while (roundedUpCapacity < capacity) {
        roundedUpCapacity = 8*roundedUpCapacity;
    }
    return struct {
        size: 0,
        capacity: roundedUpCapacity,
        contents: newarray<uint>(roundedUpCapacity/32),
    };
}

type MarshalledBytes = struct {
    nbytes: uint,
    contents: MarshalledBytesCell,
}

type MarshalledBytesCell = struct {
    first: uint,
    rest: any,  // really a MarshalledbytesCell, but compiler can't handle recursive types
}

public func marshalledBytes_firstByte(mb: MarshalledBytes) -> uint {
    let nbytes = mb.nbytes;
    let contents = mb.contents;
    if (nbytes < 1) {
        return 0;
    }
    while (nbytes > 32) {
        contents = unsafecast<MarshalledBytesCell>(contents.rest);
        nbytes = nbytes-32;
    }
    return contents.first / asm(2, 248) uint { exp };
}

public func marshalledBytes_hash(mb: MarshalledBytes) -> bytes32 {
    // This is an easy-to-compute cryptographic hash of a MarshalledBytes
    // It is collision-free, assuming that the underlying hash operation is collision-free.

    let ret = bytes32(mb.nbytes);
    let x = unsafecast<any>(mb.contents);
    while(x != ()) {
        let cell = unsafecast<MarshalledBytesCell>(x);
        ret = hash(ret, bytes32(cell.first));
        x = cell.rest;
    }
    return ret;
}

// bytearray_unmarshalBytes unmarshals a bytestack object that we got from L1
//        returns a new bytearray holding the unmarshaled bytes
public func bytearray_unmarshalBytes(inBytes: MarshalledBytes) -> ByteArray {
    // unmarshal bytes from the bytestack data structure that we receive from L1
    let nbytes = inBytes.nbytes;
    let ba = bytearray_new(nbytes) with { size: nbytes };
    let nwords = (nbytes+31)/32;

    let words = inBytes.contents;
    while (nwords > 0) {
        nwords = nwords-1;
        ba = ba with { contents: ba.contents with { [nwords] = words.first } };
        words = unsafecast<MarshalledBytesCell>(words.rest);
    }
    return ba;
}

public func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes {
    let nbytes = ba.size;
    let nwords = (nbytes+31)/32;
    let words = unsafecast<MarshalledBytesCell>(());
    let i = 0;
    while (i < nwords) {
        words = struct {
            first: ba.contents[i],
            rest: words,
        };
        i = i+1;
    }
    return struct {
        nbytes: nbytes,
        contents: words,
    };
}

// bytearray_size gets the size of a ByteArray
public func bytearray_size(ba: ByteArray) -> uint {
    return ba.size;
}

// bytearray_getByte reads one byte from a ByteArray
public func bytearray_getByte(ba: ByteArray, offset: uint) -> uint {
    if (offset >= ba.capacity) {
        return 0;
    }
    let slot = ba.contents[offset/32];
    let byteno = 31-(offset%32);
    return (slot / (asm (2, 8*byteno) uint { exp })) & 0xff;
}

// bytearray_setbyte writes one byte to a ByteArray, returns the resulting ByteArray
public func bytearray_setByte(ba: ByteArray, offset: uint, val: uint) -> ByteArray {
    if (offset >= ba.capacity) {
        ba = bytearray_expandToFit(ba, offset+1);
    }
    if (offset >= ba.size) {
        ba = ba with { size: offset+1 };
    }
    let (newContents, _) = builtin_arrayOp(
        ba.contents, 
        offset/32, 
        struct { f: basb_closure_func, val: (31-(offset%32), val,), }
    );
    return ba with { contents: newContents };
}

// bytearray_get64 reads a chunk of 8 bytes from a ByteArray 
public func bytearray_get64(ba: ByteArray, offset: uint) -> uint {
    return bytearray_get256(ba, offset) / 0x1000000000000000000000000000000000000000000000000;
    let alignment = offset % 32;
    if (alignment <= 24) {
        let res = ba.contents[offset/32];
        return (res / asm(256, 24-alignment) uint { exp }) & 0xffffffffffffffff;
    } else {
        let res = bytearray_get256(ba, offset);
        return res / 0x1000000000000000000000000000000000000000000000000;
    }
}

// bytearray_set64 writes an 8-byte chunk to a ByteArray, returning the resulting ByteArray
public func bytearray_set64(ba: ByteArray, offset: uint, value: uint) -> ByteArray {
    if (offset+8 > ba.size) {
        ba = bytearray_expandToFit(ba, offset+8);
    }
    let lowWordIndex = offset / 32;
    let alignment = offset % 32;
    if (alignment <= 24) {
        let res = builtin_arrayOp(
            ba.contents,
            lowWordIndex,
            struct{ f: bas64_single_closure_func, val: (alignment, value,), }
        );
        return ba with { contents: res.0 };
    } else {
        let res = builtin_arrayOpConsecutive(
            ba.contents,
            lowWordIndex,
            struct { f: bas64_low_closure_func, val: (alignment, value,), },
            struct { f: basmulti_hi_closure_func, val: (alignment, value,), }
        );
        return ba with { contents: res.0 };
    }
}

// bytearray_get256 reads a chunk of 32 bytes from a ByteArray
public func bytearray_get256(ba: ByteArray, offset: uint) -> uint {
    let lowWordIndex = offset / 32;
    let alignment = offset % 32;
    if (alignment == 0) {
        if (offset+32 > ba.capacity) {
            // because capacity is a multiple of 32 in this case, access is entirely beyond size
            return 0;
        } 
        return ba.contents[lowWordIndex];
    } else {
        let lowWord = 0;  // word from lower-numbered array slot
        let hiWord = 0;   // word from higher-numbered array slot

        if (offset+32 > ba.capacity) {
            // read contents, but only if they exist; otherwise let xxxWord remain 0
            let offsetBase = offset & ~0x1f;
            let offsetBaseDiv32 = offsetBase / 32;
            if (offsetBase < ba.capacity) {
                lowWord = ba.contents[offsetBaseDiv32];
                if (offsetBase+32 < ba.capacity) {
                    hiWord = ba.contents[1+offsetBaseDiv32];
                }
            }
        } else {
            let words = builtin_arrayGetConsecutive(ba.contents, lowWordIndex);
            lowWord = words.0;
            hiWord = words.1;
        }

        let shiftFactor = asm(2, 8*alignment) uint { exp };
        let invShiftFactor = asm(2, 256-8*alignment) uint { exp };
        return (hiWord/invShiftFactor) | (lowWord*shiftFactor);
    }
}

// bytearray_set256 writes a 32-byte chunk to a ByteArray, returning the resulting ByteArray
public func bytearray_set256(ba: ByteArray, offset: uint, value: uint) -> ByteArray {
    if (offset+32 > ba.size) {
        ba = bytearray_expandToFit(ba, offset+32);
    }
    let lowWordIndex = offset / 32;
    let alignment = offset % 32;
    if (alignment == 0) {
        return ba with {
            contents: ba.contents with { [lowWordIndex] = value }
        };
    } else {
        let res = builtin_arrayOpConsecutive(
            ba.contents,
            lowWordIndex,
            struct { f: bas256_low_closure_func, val: (alignment, value,), },
            struct { f: basmulti_hi_closure_func, val: (alignment, value,), }
        );
        return ba with { contents: res.0 };
    }
}

// bytearray_copy copies bytes from one ByteArray to another, 
//       returning the updated destination ByteArray
public func bytearray_copy(
    from: ByteArray, 
    fromOffset: uint,
    to: ByteArray,
    toOffset: uint,
    nbytes: uint,
) -> ByteArray {
    // TODO: optimize this to exploit alignment and speed up the endgame
    while (nbytes >= 32) {
        let val = bytearray_get256(from, fromOffset);
        to = bytearray_set256(to, toOffset, val);
        fromOffset = 32+fromOffset;
        toOffset = 32+toOffset;
        nbytes = nbytes-32;
    }
    while (nbytes > 0) {
        let val = bytearray_getByte(from, fromOffset);
        to = bytearray_setByte(to, toOffset, val);
        fromOffset = 1+fromOffset;
        toOffset = 1+toOffset;
        nbytes = nbytes-1;
    }
    return to;
}

public func bytearray_extract(from: ByteArray, offset: uint, nbytes: uint) -> ByteArray {
    let to = bytearray_new(nbytes);
    return bytearray_copy(from, offset, to, 0, nbytes);
}

func bytearray_expandToFit(ba: ByteArray, neededCapacity: uint) -> ByteArray {
    if (ba.size < neededCapacity) {
        ba = ba with { size: neededCapacity };
        if (ba.capacity < neededCapacity) {
            let newCapacity = ba.capacity*8;
            while (newCapacity < neededCapacity) {
                    newCapacity = 8*newCapacity;
            }
            return ba with { capacity: newCapacity }
                      with { contents: array_resize(ba.contents, newCapacity/32, 0) };
        } else {
            return ba;
        }
    } else {
        return ba;
    }
}

func basb_closure_func(args: (uint, uint), oldval: uint) -> (uint, uint) { // returns (newval, junk)
    let (subidx, newbval,) = args;
    let shiftFac = asm (2, 8*subidx) uint { exp };
    let mask = 0xff * shiftFac;
    let pasteIn = (newbval & 0xff) * shiftFac;
    return (
        (oldval & ~mask) | pasteIn,
        0, 
    );
}

func bas64_single_closure_func(args: (uint, uint), oldval: uint) -> (uint, uint) { // returns (newval, junk)
    let (subidx, newbval,) = args;
    let shiftFac = asm (2, 8*subidx) uint { exp };
    let mask = 0xffffffffffffffff * shiftFac;
    let pasteIn = (newbval & 0xff) * shiftFac;
    return (
        (oldval & ~mask) | pasteIn,
        0, 
    );
}

func basmulti_hi_closure_func(args: (uint, uint), oldval: uint) -> (uint, uint) { // returns (newval, junk)
    let (alignment, value,) = args; 
    let revAlignment = 32-alignment;
    let factor = asm(2, 8*revAlignment) uint { exp };
    let newVal = (value*factor) | (oldval & (factor-1));
    return (newVal, 0,);
}

func bas64_low_closure_func(args: (uint, uint), oldval: uint) -> (uint, uint) { // returns (newval, junk)
    let (alignment, value,) = args; 
    let revAlignment = 8-alignment;
    let factor = asm(2, 8*alignment) uint { exp };
    let invFactor = asm(2, 8*revAlignment) uint { exp };
    let newVal = (value/factor) | (oldval & (invFactor * ~0));
    return (newVal, 0,);
}

func bas256_low_closure_func(args: (uint, uint), oldval: uint) -> (uint, uint) { // returns (newval, junk)
    let (alignment, value,) = args; 
    let revAlignment = 32-alignment;
    let factor = asm(2, 8*alignment) uint { exp };
    let invFactor = asm(2, 8*revAlignment) uint { exp };
    let newVal = (value/factor) | (oldval & (invFactor * ~0));
    return (newVal, 0,);
}