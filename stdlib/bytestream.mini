//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;

import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, offset: uint) -> uint;
import func bytearray_get64(ba: ByteArray, offset: uint) -> uint;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_extract(ba: ByteArray, offset: uint, nbytes: uint) -> ByteArray;

type ByteStream = struct {
    contents: ByteArray,
    capacity: uint,
    currentOffset: uint,
    cache: option<uint>,
}

public func bytestream_new(contents: ByteArray) -> ByteStream {
    return struct {
        contents: contents,
        capacity: bytearray_size(contents),
        currentOffset: 0,
        cache: None<uint>,
    };
}

public func bytestream_atEof(bs: ByteStream) -> bool {
    return bs.currentOffset >= bs.capacity;
}

public func bytestream_bytesReadSoFar(bs: ByteStream) -> uint {
    return bs.currentOffset;
}

public func bytestream_bytesRemaining(bs: ByteStream) -> uint {
    return bs.capacity - bs.currentOffset;
}

public func bytestream_skipBytes(bs: ByteStream, nbytes: uint) -> option<ByteStream> {
    let newOffset = bs.currentOffset + nbytes;
    if (newOffset <= bs.capacity) {
        return Some(bs with { currentOffset: newOffset });
    } else {
        return None;
    }
}

public func bytestream_truncate(bs: ByteStream, size: uint) -> ByteStream {
    if (size < bs.capacity) {
        if (size < bs.currentOffset) {
            return bs with { capacity: bs.currentOffset };
        } else {
            return bs with { capacity: size };
        }
    } else {
        return bs;
    }
}

public func bytestream_getByte(bs: ByteStream) -> option<(ByteStream, uint)> {
    if (bs.currentOffset >= bs.capacity) {
        return None;
    } else {
        let cache = 0;
        let offsetMod32 = bs.currentOffset % 32;
        if let Some(c) = bs.cache {
            if (offsetMod32 == 0) {
                cache = bytearray_get256(bs.contents, bs.currentOffset);
                bs = bs with { cache: Some(cache) };
            } else {
                cache = c;
            }
        } else {
            cache = bytearray_get256(bs.contents, bs.currentOffset & 0x1f);
            bs = bs with { cache: Some(cache) };
        }
        return Some((
            bs with { currentOffset: bs.currentOffset+1 },
            (cache / asm (2, 8*(31-offsetMod32)) uint { exp }) & 0xff
        ));
    }
}

public func bytestream_get64(bs: ByteStream) -> option<(ByteStream, uint)> {
    if (bs.currentOffset+8 > bs.capacity) {
        return None;
    } else {
        return Some((
            bs with { currentOffset: bs.currentOffset+8 } with { cache: None<uint> },
            bytearray_get64(bs.contents, bs.currentOffset)
        ));
    }
}

public func bytestream_getUint(bs: ByteStream) -> option<(ByteStream, uint)> {
    if (bs.currentOffset+32 > bs.capacity) {
        return None;
    } else {
        return Some((
            bs with { currentOffset: bs.currentOffset+32 } with { cache: None<uint> },
            bytearray_get256(bs.contents, bs.currentOffset)
        ));
    }
}

public func bytestream_getRemainingBytes(bs: ByteStream) -> ByteArray {
    return bytearray_extract(
        bs.contents,
        bs.currentOffset,
        bs.capacity - bs.currentOffset
    );
}
