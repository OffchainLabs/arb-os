//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import func array_resize(a: []PqItem, newSize: uint, baseVal: any) -> []PqItem;

type PqItem = struct {
    priority: uint,
    item: any,
}

type PriorityQ = struct {
    size: uint,
    capacity: uint,
    contents: []PqItem,
}

public func priorityq_new() -> PriorityQ {
    return struct {
        size: 0,
        capacity: 8,
        contents: newarray<PqItem>(8),
    };
}

public func priorityq_isEmpty(pq: PriorityQ) -> bool {
    return pq.size == 0;
}

public func priorityq_size(pq: PriorityQ) -> uint {
    return pq.size;
}

// priorityq_get returns (false, null, pq) if empty; otherwise (true, item, updatedPq)
public func priorityq_get(pq: PriorityQ) -> (bool, any, PriorityQ) {  
    if (priorityq_isEmpty(pq)) {
        return (false, null, pq,);
    } else {
        let ret = pq.contents[0].item;
        let newpq = pq with { size: pq.size-1 }
                       with { contents: pq.contents with { [0] = pq.contents[pq.size-1] } };
        return (true, ret, pq_pushDown(newpq, 0),);
    }
}

func pq_pushDown(pq: PriorityQ, index: uint) -> PriorityQ {
    loop {
        let firstKidIdx = 2*index+1;
        if (firstKidIdx >= pq.size) {
            return pq;
        } elseif (firstKidIdx+1 == pq.size) {
            // only one kid is in play
            let this = pq.contents[index];
            let kid = pq.contents[firstKidIdx];
            if (kid.priority > this.priority) {
                return pq with { contents: pq.contents with { [index] = kid }
                                                       with { [firstKidIdx] = this } };
            } else {
                return pq;
            }
        } else {
            let this = pq.contents[index];
            let firstKid = pq.contents[firstKidIdx];
            let secondKidIdx = firstKidIdx+1;
            let secondKid = pq.contents[secondKidIdx];
            if (firstKid.priority > secondKid.priority) {
                if (firstKid.priority > this.priority) {
                    pq = pq with { contents: pq.contents with { [index] = firstKid }
                                                         with { [firstKidIdx] = this } };
                    index = firstKidIdx;
                } else {
                    return pq;
                }
            } else {
               if (secondKid.priority > this.priority) {
                    pq = pq with { contents: pq.contents with { [index] = secondKid }
                                                         with { [secondKidIdx] = this } };
                    index = secondKidIdx;
                } else {
                    return pq;
                }
            }
        }
    }
}

func pq_pushUp(pq: PriorityQ, index: uint) -> PriorityQ {
    let this = pq.contents[index];
    loop {
        if (index == 0) {
            return pq;
        }
        let parentIdx = (index-1)/2;
        let parent = pq.contents[parentIdx];
        if (parent.priority >= this.priority) {
            return pq;
        } else {
            pq = pq with { contents: pq.contents with { [index] = parent }
                                                 with { [parentIdx] = this } };
            index = parentIdx;
        }
    }
}

public func priorityq_insert(pq: PriorityQ, item: any, priority: uint) -> PriorityQ {
    if (pq.size == pq.capacity) {
        let newCapacity = 8*pq.capacity;
        pq = pq with { capacity: newCapacity }
                with { contents: array_resize(pq.contents, newCapacity, null) };
    }
    let index = pq.size;
    let newpq = pq with { size: index+1 }
                   with { contents: pq.contents with { [index] = struct { priority: priority, item: item, } } };
    return pq_pushUp(newpq, index);
}

public func priorityq_printAsArray(pq: PriorityQ) -> uint {
    let ret = pq.size;
    let cont = pq.contents;
    let i = 0;
    while (i < ret) {
        debug(cont[i]);
        i = i+1;
    }
    return ret;
}