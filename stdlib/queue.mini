//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

type BoundedQueue = struct {
    capacity: uint,
    nextPut: uint,
    nextGet: uint,
    contents: []any,
}

public func boundedQueue_new(capacity: uint) -> BoundedQueue {
    return struct {
        capacity: capacity,
        nextPut: 0,
        nextGet: 0,
        contents: newarray<any>(capacity),
    };
}

public func boundedQueue_isEmpty(q: BoundedQueue) -> bool {
    return q.nextPut == q.nextGet;
}

public func boundedQueue_isFull(q: BoundedQueue) -> bool {
    return ((q.nextPut+1) % q.capacity) == q.nextGet;
}

public func boundedQueue_size(q: BoundedQueue) -> uint {
    return (q.nextPut + q.capacity - q.nextGet) % q.capacity;
}

public func boundedQueue_put(q: BoundedQueue, val: any) -> BoundedQueue {
    if (boundedQueue_isFull(q)) {
        return q;
    } else {
        let putIndex = q.nextPut;
        return q with { nextPut: (putIndex+1) % q.capacity } 
                 with { contents: q.contents with { [putIndex] = val } };
    }
}

public func boundedQueue_get(q: BoundedQueue) -> option<(BoundedQueue, any)> {
    if (boundedQueue_isEmpty(q)) {
        return None;
    } else {
        return Some((
            q with { nextGet: (q.nextGet+1) % q.capacity },
            q.contents[q.nextGet],
        ));
    }
}

public func boundedQueue_peek(q: BoundedQueue) -> option<any> {
    if (boundedQueue_isEmpty(q)) {
        return None;
    } else {
        return Some(q.contents[q.nextGet]);
    }
}

public func boundedQueue_discardOneIfNonempty(q: BoundedQueue) -> option<BoundedQueue> {
    if (boundedQueue_isEmpty(q)) {
        return None;
    } else {
        return Some(q with { nextGet: (q.nextGet+1) % q.capacity });
    }
}

public func boundedQueue_expand(q: BoundedQueue, newSize: uint) -> BoundedQueue {
    if (newSize <= q.capacity) {
        panic;
    }
    let newQ = boundedQueue_new(newSize);
    while ( ! boundedQueue_isEmpty(q) ) {
        if let Some(res) = boundedQueue_get(q) {
            q = res.0;
            newQ = boundedQueue_put(newQ, res.1);
        } else {
            panic;
        }
    }
    return newQ;
}

type Queue = BoundedQueue

public func queue_new() -> Queue {
    return boundedQueue_new(8);
}

public func queue_isEmpty(q: Queue) -> bool {
    return boundedQueue_isEmpty(q);
}

public func queue_size(q: Queue) -> uint {
    return boundedQueue_size(q);
}

public func queue_put(q: Queue, val: any) -> Queue {
    if (boundedQueue_isFull(q)) {
        q = boundedQueue_expand(q, 2*q.capacity);
    }
    return boundedQueue_put(q, val);
}

public func queue_get(q: Queue) -> option<(Queue, any)> {
    return boundedQueue_get(q);
}

public func queue_peek(q: Queue) -> option<any> {
    return boundedQueue_peek(q);
}

public func queue_discardOneIfNonempty(q: Queue) -> option<Queue> {
    return boundedQueue_discardOneIfNonempty(q);
}

