//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type MarshalledBytes;

import func bytearray_new(size: uint) -> ByteArray;
import func bytearray_unmarshalBytes(mbytes: MarshalledBytes) -> ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, idx: uint) -> uint;
import func bytearray_setByte(ba: ByteArray, idx: uint, val: uint) -> ByteArray;
import func bytearray_get64(ba: ByteArray, idx: uint) -> uint;
import func bytearray_set64(ba: ByteArray, idx: uint, val: uint) -> ByteArray;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_set256(ba: ByteArray, offset: uint, value: uint) -> ByteArray;
import func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes;
import func bytearray_extract(ba: ByteArray, offset: uint, nbytes: uint) -> ByteArray;
import func bytearray_copy(from: ByteArray, fromOffset: uint, to: ByteArray, toOffset: uint, nbytes: uint) -> ByteArray;

import func marshalledBytes_hash(mb: MarshalledBytes) -> bytes32;


impure func main() {
	asm(tests(),) { log };
}

func tests() -> uint {
	let ba = bytearray_new(33);
	if (bytearray_size(ba) != 0) {
		return 1;
	}

	ba = bytearray_new(117);
	ba = bytearray_setByte(ba, 33, 42);
    if (bytearray_getByte(ba, 33) != 42) {
	    return 2;
    }

	ba = bytearray_new(117);
	ba = bytearray_setByte(ba, 33, 42);
    ba = bytearray_setByte(ba, 37, 99);
    if (bytearray_getByte(ba, 33) != 42) {
		return 3;
	}

	ba = bytearray_new(117);
	ba = bytearray_setByte(ba, 37, 42+99*256);
	ba = bytearray_setByte(ba, 36, 999999999999999999);
    if (bytearray_getByte(ba, 37) != 42) {
		return 4;
	}

	ba = bytearray_new(117);
	ba = bytearray_set256(ba, 64, 7373);
	if (bytearray_get256(ba, 64) != 7373) {
		return 5;
	}

	ba = bytearray_new(117);
	ba = bytearray_set256(ba, 64, 7373);
	let res = bytearray_get256(ba, 63);
	if (res != 7373/256) {
	    return 60000+res;
	}

	ba = bytearray_new(117);
	ba = bytearray_set256(ba, 13, ~0);
	ba = bytearray_set256(ba, 13+32, 0);
	ba = bytearray_set256(ba, 13+64, ~0);
	if ( (bytearray_get256(ba, 13) != ~0)
		|| (bytearray_get256(ba, 13+32) != 0)
		|| (bytearray_get256(ba, 13+64) != ~0) ) {
		return 7;
	}

	let marshalledStruct = unsafecast<MarshalledBytes>((
		67,
		(
			0x4041420000000000000000000000000000000000000000000000000000000000,
			(
				0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f,
				(
					0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,
					null,
				),
			),
		),
	));

	ba = bytearray_new(67);
	ba = bytearray_unmarshalBytes(marshalledStruct);
	let i = 0;
	while (i < 67) {
		let b = bytearray_getByte(ba, i);
		if (b != i) {
			return 100+i;
		}
		i = i+1;
	}

	ba = setupFromUnmarshal();
	let res = bytearray_get64(ba, 3);
	if (res != 0x030405060708090a) {
		return 9;
    }

	ba = setupFromUnmarshal();
	if (bytearray_get64(ba, 29) != 0x1d1e1f2021222324) {
		return 10;
	}

	ba = setupFromUnmarshal();
	let before = bytearray_get256(ba, 32);
	let _ = bytearray_get64(ba, 29); // ^ 0x24232221201f1e1d;
	if (bytearray_get256(ba, 32) != before) {
		return 11;
	}

	// test for big-endian byte order
	ba = bytearray_new(32);
	ba = bytearray_setByte(ba, 31, 1);
	if (bytearray_get256(ba, 0) != 1) {
	    return 12;
	}

    if (bytes32(0x4fc384a19926e9ff7ec8f2376a0d146dc273031df1db4d133236d209700e4780)
        != marshalledBytes_hash(bytearray_marshalFull(setupFromUnmarshal()))
    ) {
        return 13;
    }

    if (bytes32(0x6203cb97ced4e35e64eeaddf64d03b68bcb81b5ee3cb0205f7edb755a8a4198)
            != marshalledBytes_hash(bytearray_marshalFull(bytearray_setByte(bytearray_new(0), 0, 13)))
    ) {
        return 14;
    }

    if (bytes32(0x2286697a7baf78c99024b26bd236a05975a57714bf44a9b7400fe583b31fa274)
            != marshalledBytes_hash(bytearray_marshalFull(bytearray_set256(bytearray_new(0), 0, 0x6203cb97ced4e35e64eeaddf64d03b68bcb81b5ee3cb0205f7edb755a8a4198)))
    ) {
        return 15;
    }

    let ba = setupFromUnmarshal();
    let ba2 = bytearray_extract(ba, 0, 41);
    let ba3 = bytearray_copy(ba, 0, bytearray_new(0), 0, 41);
    if (bytearray_marshalFull(ba2) != bytearray_marshalFull(ba3)) {
        return 16;
    }

	return 0;
}

func setupFromUnmarshal() -> ByteArray {
	let marshalledStruct = unsafecast<MarshalledBytes>((
		67,
		(
			0x4041420000000000000000000000000000000000000000000000000000000000,
			(
				0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f,
				(
				    0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,
					null,
				),
			),
		),
	));
	return bytearray_unmarshalBytes(marshalledStruct);
}
