//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type AccountStore;
import type Account;
import type ByteArray;
import type MarshalledBytes;
import type MessageBatch;
import type Queue;

import func chainParams_chainId() -> uint;

import func getGlobalAccountStore() -> AccountStore;
import func setGlobalAccountStore(acctStore: AccountStore);
import func accountStore_get(acctStore: AccountStore, addr: address) -> Account;
import func accountStore_set(acctStore: AccountStore, addr: address, acct: Account) -> AccountStore;
import func account_addToEthBalance(acct: Account, amount: uint) -> Account;
import func account_deductFromEthBalance(acct: Account, amount: uint) -> option<Account>;

import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytearray_getByte(ba: ByteArray, offset: uint) -> uint;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func marshalledBytes_firstByte(mb: MarshalledBytes) -> uint;

import func queue_new() -> Queue;
import func queue_isEmpty(q: Queue) -> bool;
import func queue_put(q: Queue, item: any) -> Queue;
import func queue_get(q: Queue) -> option<(Queue, any)>;

import impure func inbox_get() -> IncomingRequest;
import impure func outputStats_endOfBlock(blockNum: uint, timestamp: uint);

import func messageBatch_tryNew(msg: IncomingRequest) -> option<MessageBatch>;
import func messageBatch_get(batch: MessageBatch) -> option<(IncomingRequest, MessageBatch)>;

import func hashL2messageInfo(l2msg: MarshalledBytes, chainId: uint, sender: address) -> bytes32;

import func translateSignedTx(req: IncomingRequest) -> option<IncomingRequest>;

var gasAccountingInfo: struct {
    gasUsedByOS: uint,            // amount of gas used by OS that validators haven't yet been compensated for
    weiCollectedFromTxs: uint,    // amount of currency collected from txs but not yet paid out to validators
    txState: option<TxGasState>,  // status of currently active tx (if there is one)
    queuedFromBatch: Queue,       // messages that arrived in a batch and are waiting for be handled
};

type TxGasState = struct {
    gasInReserve: uint,   // how much gas is being held in reserve
    originalMax: uint,   // the tx's original maxGas value
    price: uint,         // price of gas, in wei per unit of gas
    weiHeldForGas: uint, // amount of currency we're holding to cover the current tx's gas use
    refundTo: address,   // who gets a refund for unused gas at the end, if there is any
}

type GasUsage = struct {
    gasUsed: uint,
    gasPriceWei: uint,
}

public impure func gasAccounting_init() {
    gasAccountingInfo = struct {
        gasUsedByOS: 0,
        weiCollectedFromTxs: 0,
        txState: None<TxGasState>,
        queuedFromBatch: queue_new(),
    };
}

// The currently-running Tx has some amount of gas remaining. That gas can be in two places:
// *  in the ArbGasRemaining register, if that register is < 2**255
// *  in reserve
//
// The state of the ArbGasRemaining register tells us whether we're currently charging gas to the tx or to the OS.
// *  If the register is < 2**255, we're charging to the tx
// *  If the register is >= 2**255, we're charging to the OS
// Note that if execution in the tx (or a subcall it makes) runs out of gas, this will generate an Error and
//    set ArbGasRemaining to 2**256 - 1, which correctly puts us into the mode of charging the OS.
// If there is an Error, the Error handler will call us, to inform us that there might have been an out-of-gas situation.
//    (It's up to us to figure out whether there actually was an out-of-gas situation, vs some unrelated error.)
//
// When a new tx starts, we take enough Eth from it to cover its maxGas.
// When that tx is done, we give it a refund for any unused gas.

public impure func gasAccounting_startTxCharges(
    maxGas: uint,
    gasPrice: uint,
    payer: address
) -> option<()> {
    // Start charging a new Tx for ArbGas usage
    // The caller should already have verified that the payer has enough funds, but we'll return None if not.

    if (maxGas >= asm(255, 1) uint { shl }) {
        maxGas = asm(255, 1) uint { shl } - 1;
    }

    // take funds from the payer, enough to pay for maxGas at gasPrice
    let weiToHold = maxGas * gasPrice;
    let globalAS = getGlobalAccountStore();
    setGlobalAccountStore(
        accountStore_set(
            globalAS,
            payer,
            account_deductFromEthBalance(
                accountStore_get(globalAS, payer),
                weiToHold
            )?   // note: returns None if insufficient balance
        )
    );

    gasAccountingInfo = gasAccountingInfo with {
        gasUsedByOS: gasAccountingInfo.gasUsedByOS + ((~0) - asm() uint { getgas })
    } with {
        txState: Some(struct {
            gasInReserve: 0,
            originalMax: maxGas,
            price: gasPrice,
            weiHeldForGas: weiToHold,
            refundTo: payer,
        })
    };

    asm(maxGas,) { setgas };
    return Some(());
}

public impure func gasAccounting_endTxCharges() -> option<GasUsage> {
    // stop charging the current tx for gas
    // refund any unused gas
    // return the total amount it used, or None if there isn't a tx active

    // switch over to charging the OS for gas
    let txState = gasAccountingInfo.txState?;
    let gasToRefund = txState.gasInReserve + switchToChargingOS();

    // refund the unused gas
    let refund = gasToRefund * txState.price;
    let globalAS = getGlobalAccountStore();
    setGlobalAccountStore(
        accountStore_set(
            globalAS,
            txState.refundTo,
            account_addToEthBalance(
                accountStore_get(globalAS, txState.refundTo),
                refund
            )
        )
    );
    gasAccountingInfo = gasAccountingInfo with {
        weiCollectedFromTxs: gasAccountingInfo.weiCollectedFromTxs
                                + (txState.weiHeldForGas - refund)
    } with {
        txState: None<TxGasState>
    };

    return Some(
        struct {
            gasUsed: txState.originalMax-gasToRefund,
            gasPriceWei: txState.price
        }
    );
}

public impure func gasAccounting_pauseTxCharges() -> uint {
    // pause charging the currently running tx
    // return how many units of the tx's initial maxGas are still unused

    if let Some(txState) = gasAccountingInfo.txState {
        let gasRemaining = txState.gasInReserve + switchToChargingOS();
        gasAccountingInfo = gasAccountingInfo with {
            txState: Some(
                txState with {
                    gasInReserve: gasRemaining
                }
            )
        };
        return gasRemaining;
    } else {
        // oops, someone tried to pause tx charges when there's no active tx
        // to be safe, report that the tx is completely out of gas
        return 0;
    }
}

public impure func gasAccounting_resumeTxCharges(allocationRequested: uint) -> uint {
    // resume the charging of the tx for gas
    // allocationRequested is how much of its gas the tx wants to allocate
    // return how much gas we actually allocated = min(requested, available)

    if let Some(txState) = gasAccountingInfo.txState {
        if (allocationRequested > txState.gasInReserve) {
            allocationRequested = txState.gasInReserve;  // can't request more gas than you have
        }
        gasAccountingInfo = gasAccountingInfo with {
            txState: Some(
                txState with {
                    gasInReserve: txState.gasInReserve - allocationRequested
                }
            )
        };

        asm(allocationRequested,) { setgas };  // start charging the application
        return allocationRequested;
    } else {
        // something went wrong: tried to resume tx charges when there isn't an active tx
        // to be safe, report that tx is completely out of gas
        return 0;
    }
}

impure func switchToChargingOS() -> uint {
    // switch to charging the OS for gas, if we aren't already
    // return amount of the tx's gas that was left over in ArbGasRemaining
    let gasRemaining = asm() uint { getgas };
    if (gasRemaining >= asm(255, 1) uint { shl }) {
        // we were already charging the OS, tx has nothing remaining
        return 0;
    } else {
        // we were charging the tx; switch to charging the OS and return tx's unused amount from ArbGasRemaining
        asm(~0,) { setgas };
        return gasRemaining;
    }
}

// This is the structure that the Arbitrum protocol gives us, for each incoming message.
// It is declared identically in inbox.mini and elsewhere
type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,          // sequence number in L1 inbox
    msgData: MarshalledBytes  // contents of the message, as a marshalled bytearray
}

// The next section of code implements the congestion auction. For each tx request, the auction
//     determines (a) whether to approve the tx for execution, and (b) what gas price the tx will pay.
// This uses a "pull" interface: the main run loop calls this to get the next message.
//     This code will in turn call back to the inbox to pull in incoming messages from the L1.
// Eventually this component will pull in a group of messages from the L1 inbox, run the congestion
//     auction over them, then enqueue them to be eventually fetched by the main run loop.
// For now, this approves every message, and charges zero gas price.
// Note that this component also is responsible for unpacking messages that arrive in a batch
//     (that is, multiple messages packed together in a single L1 message. When this component
//     sees a batch, it unbundles the batch, checks the signature on each item in the batch,
//     "rehydrates" the items with valid signatures into regular messages, and enqueues them.

public impure func getNextMsgFromCongestionAuction() -> (
    IncomingRequest,  // a message
    bool,           // was it approved for execution
    uint,           // maxGas it's allowed to use
    uint,           // gas price it will pay
) {
    // For now, the gas auction is a no-op.  It just approves every message at zero gas price.
    let msg = unsafecast<IncomingRequest>(());   // value will be re-initialized before use
    loop {
        if let Some(sideloadedTuple) = trySideload() {
            return sideloadedTuple;
        }

        if let Some(res) = queue_get(gasAccountingInfo.queuedFromBatch) {
            let (newQ, rawMsg) = res;
            gasAccountingInfo = gasAccountingInfo with {
                queuedFromBatch: newQ
            };
            msg = unsafecast<IncomingRequest>(rawMsg);
        } else {
            msg = inbox_get();
        }

        if let Some(batch) = messageBatch_tryNew(msg) {
            // it's a batch message, so unpack its components and queue them
            let moreToDo = true;
            let queue = gasAccountingInfo.queuedFromBatch;
            while (moreToDo) {
                if let Some(res) = messageBatch_get(batch) {
                    let (newMsg, restOfBatch) = res;
                    queue = queue_put(queue, newMsg);
                    batch = restOfBatch;
                } else {
                    moreToDo = false;
                }
            }
            gasAccountingInfo = gasAccountingInfo with {
                queuedFromBatch: queue
            };
        } else {
            // it's not a batch, so process it immediately
            // get its maxGas amount -- for now, set the limit high, unless caller asked for less
            let maxGas = 1000000000;
            if (msg.kind == 6) {
                // it's an end-of-block message, so just trigger end-of-block processing
                outputStats_endOfBlock(msg.blockNumber, msg.timestamp);
            } elseif (msg.kind == 3) {
                // it's an L2 message, so switch based on the L2 type
                let firstByte = marshalledBytes_firstByte(msg.msgData);
                if (firstByte == 6) {
                    // it's a heartbeat message, don't do anything
                } elseif (firstByte == 4) {
                    // it's a signed tx; verify sig and then process request or discard
                    if let Some(verifiedMsg) = translateSignedTx(msg) {
                        let ba = bytearray_unmarshalBytes(verifiedMsg.msgData);
                        let maxGas = bytearray_get256(ba, 1);
                        return (verifiedMsg, true, maxGas, 0);
                    }
                    // else signature was invalid, ignore msg and execute loop again to get another
                } else {
                    let ba = bytearray_unmarshalBytes(msg.msgData);
                    if (firstByte == 0) {
                        // it's an unsigned tx; compute unique requestId
                        msg = msg with {
                            requestId: uint(hashL2messageInfo(
                                msg.msgData,
                                chainParams_chainId(),
                                msg.sender
                            ))
                        };
                    }
                    let maxGas = bytearray_get256(ba, 1);
                    return (msg, true, maxGas, 0);
                }
            } else {
                return (msg, true, maxGas, 0);
            }
        }
    }
}

// The following function exists to support sideloading.
// Sideloading is a method used by validators to run non-mutating calls on their
//     private clones of a chain's state. The sideload instruction is defined to push
//     an empty tuple () onto the stack, which will cause this procedure to always
//     return None when executed by an Arbitrum chain.
// But a validator (or really any "full node" on an Arbitrum chain) wants to be able to
//     run non-mutating calls on a private clone of the chain, so that it can get
//     correct results from those non-mutating calls without having to use the more
//     expensive public protocol. To do this, a validator will make a private clone of the
//     chain's state, then "sideload" messages asking for the non-mutating calls into the
//     private clone.
// So in the private clone only, a validator can cause the sideload instruction to push
//     onto the stack a pair (message, gasLimit).  This function will then return that
//     pair, which will cause (the private clone of) the chain to run that call, with the
//     given gasLimit and zero gas price.
impure func trySideload() -> option<(IncomingRequest, bool, uint, uint)> {
    let sideloadedVal = asm() any { sideload };
    if (sideloadedVal == ()) {
        // normal case; the official chain will always be in this case
        return None;
    } else {
        // don't worry about the unsafecast; this can't execute on the official chain
        let (msg, gasLimit) = unsafecast<(IncomingRequest, uint)>(sideloadedVal);
        return Some((msg, true, gasLimit, 0));
    }
}