//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type AccountStore;
import type MarshalledBytes;
import type ByteArray;
import type ByteStream;
import type EvmLogs;
import type GasUsage;
import type StorageMap;

import impure func errorHandler_init();
import impure func chainParams_init();
import impure func gasAccounting_init();
import impure func evmCallStack_init();
import impure func inbox_init();
import impure func accountStore_init();
import impure func precompiles_init(acctStore: AccountStore) -> option<AccountStore>;
import impure func txReceipts_init();

import impure func getGlobalAccountStore() -> AccountStore;
import impure func setGlobalAccountStore(acctStore: AccountStore);
import func accountStore_createAccountFromEvmCode(
    store: AccountStore,
    newAddr: address,
    code: ByteArray,
    evmJumpTable: map<uint, impure func()>,
    initCodePt: impure func(),
    storageMap: StorageMap
) -> option<AccountStore>;
import impure func translateEvmCodeSegment(
    bs: ByteStream
) -> option<(impure func(), map<uint, impure func()>)>;
import func bytearray_new(capacityHint: uint) -> ByteArray;
import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytestream_new(ba: ByteArray) -> ByteStream;
import func getErc20code() -> MarshalledBytes;
import func getErc721code() -> MarshalledBytes;
import func getArbInfoCode() -> MarshalledBytes;
import func getErc20address() -> address;
import func getErc721address() -> address;
import func getArbInfoAddress() -> address;
import func getErc20storage() -> StorageMap;
import func getErc721storage() -> StorageMap;
import func getArbInfoStorage() -> StorageMap;

import impure func inbox_get() -> IncomingRequest;
import impure func getNextRequestFromCongestionAuction() -> (
    bool,           // was it approved for execution
    option<IncomingRequest>,  // if it was an L1 message
    option<TxRequestData>,    // if it was an L2 tx message
);
import impure func handleL1Request(
    msg: IncomingRequest,
) -> option<()>; // return None if message format error; Some(()) if other error; if no error, never return
import impure func handleL2Request(
    inStream: ByteStream,
    request: TxRequestData
) -> option<()>; // return None if message format error; Some(()) if other error; if no error, never return
import impure func emitLog(
    l1message: IncomingRequest,
    resultCode: uint,
    maybeReturnData: option<ByteArray>,
    maybeEvmLogs: option<EvmLogs>,
    gasUsage: option<GasUsage>,
);
import impure func arbsys_txcall();

// This structure defines an incoming request.
// It is declared identically in inbox.mini and elsewhere.
type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,
    msgData: MarshalledBytes  // kind-specific data, as a marshalled bytearray
}

// TxRequestData is declared identically in message.mini and elsewhere.
type TxRequestData = struct {
    maxGas: uint,
    gasPrice: uint,
    seqNum: option<uint>,
    caller: address,
    calleeAddr: address,
    value: uint,
    calldata: ByteArray,
    incomingRequest: IncomingRequest,
}


impure func main() {
    errorHandler_init();
    chainParams_init();
    gasAccounting_init();
    evmCallStack_init();
    inbox_init();
    accountStore_init();
    txReceipts_init();
    if (initializeContractTemplates() == None<()>) {
        panic;   // don't try to run without contract templates
    }
    
    mainRunLoop();
}

public impure func mainRunLoop() {
    loop {
        let (approved, maybeL1, maybeL2) = getNextRequestFromCongestionAuction();
        if let Some(msg) = maybeL1 {
            if (approved) {
                if(handleL1Request(msg) == None<()>) {
                    // reject for message format error
                    emitLog(msg, 6, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
                }
            } else {
                // reject for congestion error
                emitLog(msg, 2, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
            }
        } else {
            if let Some(request) = maybeL2 {
                if (approved) {
                    if (handleL2Request(
                        bytestream_new(bytearray_unmarshalBytes(request.incomingRequest.msgData)),
                        request
                    ) == None<()>) {
                        // reject for message format error
                        emitLog(request.incomingRequest, 6, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
                    }
                } else {
                    // reject for congestion error
                    emitLog(request.incomingRequest, 2, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
                }
            } // else request was not identified as either L1 or L2, which should be impossible
        }
        // if we reach here, message has already been handled and log already sent
    }
}

impure func initializeContractTemplates() -> option<()> {
    let acctStore = getGlobalAccountStore();

    let code = bytearray_unmarshalBytes(getErc20code());
    let (initCodePt, evmJumpTable) = translateEvmCodeSegment(
        bytestream_new(code)
    )?;
    acctStore = accountStore_createAccountFromEvmCode(
        acctStore,
        getErc20address(),
        code,
        evmJumpTable,
        initCodePt,
        getErc20storage()
    )?;

    let code = bytearray_unmarshalBytes(getErc721code());
    let (initCodePt, evmJumpTable) = translateEvmCodeSegment(
        bytestream_new(code)
    )?;
    acctStore = accountStore_createAccountFromEvmCode(
        acctStore,
        getErc721address(),
        code,
        evmJumpTable,
        initCodePt,
        getErc721storage()
    )?;

    let code = bytearray_unmarshalBytes(getArbInfoCode());
    let (initCodePt, evmJumpTable) = translateEvmCodeSegment(
        bytestream_new(code)
    )?;
    acctStore = accountStore_createAccountFromEvmCode(
        acctStore,
        getArbInfoAddress(),
        code,
        evmJumpTable,
        initCodePt,
        getArbInfoStorage()
    )?;

    // set up precompiled contracts
    acctStore = precompiles_init(acctStore)?;

    setGlobalAccountStore(acctStore);
    return Some(());
}

