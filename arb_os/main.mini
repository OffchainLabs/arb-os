//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type AccountStore;
import type MarshalledBytes;
import type ByteArray;
import type ByteStream;
import type IncomingRequest;
import type EvmLogs;
import type GasUsage;
import type StorageMap;

import impure func errorHandler_init();
import impure func initKeccakConstants();
import impure func chainParams_init();
import impure func gasAccounting_init();
import impure func evmCallStack_init();
import impure func inbox_init();
import impure func accountStore_init();
import impure func precompiles_init(acctStore: AccountStore) -> option<AccountStore>;
import impure func txReceipts_init();

import impure func getGlobalAccountStore() -> AccountStore;
import impure func setGlobalAccountStore(acctStore: AccountStore);
import func accountStore_createAccountFromEvmCode(
    store: AccountStore,
    newAddr: address,
    code: ByteArray,
    evmJumpTable: map<uint, impure func()>,
    initCodePt: impure func(),
    storageMap: StorageMap
) -> option<AccountStore>;
import impure func accountStore_createBuiltinContract(
    acctStore: AccountStore,
    addr: address,
    entryPoint: impure func()
) -> option<AccountStore>;
import impure func translateEvmCodeSegment(
    bs: ByteStream
) -> option<(impure func(), map<uint, impure func()>)>;
import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytestream_new(ba: ByteArray) -> ByteStream;
import func getErc20code() -> MarshalledBytes;
import func getErc721code() -> MarshalledBytes;
import func getArbInfoCode() -> MarshalledBytes;
import func getErc20address() -> address;
import func getErc721address() -> address;
import func getArbInfoAddress() -> address;
import func getErc20storage() -> StorageMap;
import func getErc721storage() -> StorageMap;
import func getArbInfoStorage() -> StorageMap;

import impure func inbox_get() -> IncomingRequest;
import impure func getNextMsgFromCongestionAuction() -> (
    IncomingRequest,  // a message
    bool,           // was it approved for execution
    uint,           // maxGas it's allowed to use
    uint,           // gas price it will pay
) ;
import impure func handleIncomingRequest(
    msg: IncomingRequest,
    maxGas: uint,
    gasPrice: uint
) -> option<()>; // return None if message format error; Some(()) if other error; if no error, never return
import impure func emitLog(
    l1message: IncomingRequest,
    resultCode: uint,
    maybeReturnData: option<ByteArray>,
    maybeEvmLogs: option<EvmLogs>,
    gasUsage: option<GasUsage>,
);
import impure func arbsys_txcall();


impure func main() {
    errorHandler_init();
    initKeccakConstants();
    chainParams_init();
    gasAccounting_init();
    evmCallStack_init();
    inbox_init();
    accountStore_init();
    txReceipts_init();
    if (initializeContractTemplates() == None<()>) {
        panic;   // don't try to run without contract templates
    }
    
    mainRunLoop();
}

public impure func mainRunLoop() {
    loop {
        let (msg, approved, maxGas, gasPrice) = getNextMsgFromCongestionAuction();
        if (approved) {
            if (handleIncomingRequest(msg, maxGas, gasPrice) == None<()>) {
                // reject for message format error
                emitLog(msg, 6, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
            }
        } else {
            // reject for congestion error
            emitLog(msg, 2, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
        }
        // if we reach here, message has already been rejected and log already sent
    }
}

impure func initializeContractTemplates() -> option<()> {
    let acctStore = getGlobalAccountStore();

    let code = bytearray_unmarshalBytes(getErc20code());
    let (initCodePt, evmJumpTable) = translateEvmCodeSegment(
        bytestream_new(code)
    )?;
    acctStore = accountStore_createAccountFromEvmCode(
        acctStore,
        getErc20address(),
        code,
        evmJumpTable,
        initCodePt,
        getErc20storage()
    )?;

    let code = bytearray_unmarshalBytes(getErc721code());
    let (initCodePt, evmJumpTable) = translateEvmCodeSegment(
        bytestream_new(code)
    )?;
    acctStore = accountStore_createAccountFromEvmCode(
        acctStore,
        getErc721address(),
        code,
        evmJumpTable,
        initCodePt,
        getErc721storage()
    )?;

    let code = bytearray_unmarshalBytes(getArbInfoCode());
    let (initCodePt, evmJumpTable) = translateEvmCodeSegment(
        bytestream_new(code)
    )?;
    acctStore = accountStore_createAccountFromEvmCode(
        acctStore,
        getArbInfoAddress(),
        code,
        evmJumpTable,
        initCodePt,
        getArbInfoStorage()
    )?;

    // set up precompiled contracts
    acctStore = precompiles_init(acctStore)?;

    setGlobalAccountStore(acctStore);
    return Some(());
}

