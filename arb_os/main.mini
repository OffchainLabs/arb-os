//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//


use accounts::AccountStore;
use accounts::accountStore_init;
use accounts::getGlobalAccountStore;
use accounts::setGlobalAccountStore;
use accounts::accountStore_createAccountFromEvmCode;
use chainParameters::chainParams_init;
use chainParameters::chainParams_haveDoneInit;
use codeSegment::codeSegment_init;
use codeSegment::translateEvmCodeSegment;
use contractTemplates::getArbInfoCode;
use contractTemplates::getArbInfoAddress;
use contractTemplates::getArbInfoStorage;
use decompression::decompression_init;
use errorHandler::errorHandler_init;
use evmCallStack::evmCallStack_init;
use evmOps::evmOps_init;
use evmlogs::EvmLogs;
use gasAccounting::GasUsage;
use gasAccounting::gasAccounting_init;
use inbox::inbox_init;
use inbox::inbox_get;
use messages::TxRequestData;
use output::output_init;
use output::txReceipts_init;
use pluggables::pluggables_init;
use precompiles::precompiles_init;
use rollupTracker::rollupTracker_init;

use std::bytearray::MarshalledBytes;
use std::bytearray::ByteArray;
use std::bytearray::bytearray_new;
use std::bytearray::bytearray_unmarshalBytes;
use std::bytestream::ByteStream;
use std::bytestream::bytestream_new;
use std::storageMap::StorageMap;


use decompression::decompression_init;
use gasAccounting::getNextRequestFromCongestionAuction;
use messages::handleL1Request; // return None if message format error; Some(()) if other error; if no error, never return
use messages::handleL2Request; // return None if message format error; Some(()) if other error; if no error, never return
use output::emitTxReceipt;
use arbsys::arbsys_txcall;

use inbox::IncomingRequest;

use upgrade::InputGlobals;
use upgrade::upgrade;


impure func main(oldGlobals: any) {
    if (oldGlobals != ()) {
        // this is an upgrade; we're inheriting the state of a previous ArbOS instance
        asm(101,) { debugprint };
        let newGlobals = upgrade(unsafecast<InputGlobals>(oldGlobals));
        asm(102,) { debugprint };
        asm(newGlobals,) { rset };
        asm(103,) { debugprint };

        // now re-do the initializations that set up pointers into the ArbOS code
        errorHandler_init();
        asm(104,) { debugprint };
        evmOps_init();
        asm(105,) { debugprint };
        if (initializePreinstalls() == None<()>) {
            asm(106,) { debugprint };
            panic;   // don't try to run without preinstalls and precompiles
        }
        asm(107,) { debugprint };
    } else {
        // this is a clean start, not an upgrade
        errorHandler_init();
        pluggables_init();
        codeSegment_init();
        chainParams_init();
        output_init();
        decompression_init();
        gasAccounting_init();
        evmCallStack_init();
        evmOps_init();
        inbox_init();
        accountStore_init();
        txReceipts_init();
        rollupTracker_init();
        if (initializePreinstalls() == None<()>) {
            panic;   // don't try to run without preinstalls and precompiles
        }
    }

    // initialize any customizations here

    mainRunLoop();
}

public impure func mainRunLoop() {
    loop {
        let (approved, maybeL1, maybeL2) = getNextRequestFromCongestionAuction();
        if let Some(msg) = maybeL1 {
            if (approved) {
                if(handleL1Request(msg) == None<()>) {
                    // reject for message format error
                    emitTxReceipt(msg, 6, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
                }
            } else {
                // reject for congestion error
                emitTxReceipt(msg, 2, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
            }
        } else {
            if let Some(request) = maybeL2 {
                if (approved) {
                    if (handleL2Request(
                        bytestream_new(request.incomingRequest.msgData),
                        request
                    ) == None<()>) {
                        // reject for message format error
                        emitTxReceipt(request.incomingRequest, 6, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
                    }
                } else {
                    // reject for congestion error
                    emitTxReceipt(
                        request.incomingRequest,
                        const::TxResultCode_congestion,
                        None<ByteArray>,
                        None<EvmLogs>,
                        None<GasUsage>
                    );
                }
            } // else request was not identified as either L1 or L2, which should be impossible
        }
        // if we reach here, message has already been handled and log already sent
    }
}

impure func initializePreinstalls() -> option<()> {
    asm(300,) { debugprint };
    let acctStore = getGlobalAccountStore();
    asm(301,) { debugprint };

    let code = bytearray_unmarshalBytes(getArbInfoCode())?;
    asm(302,) { debugprint };
    let (initCodePt, evmJumpTable, _) = translateEvmCodeSegment(
        bytestream_new(code),
        false
    )?;
    asm(303,) { debugprint };
    acctStore = accountStore_createAccountFromEvmCode(
        acctStore,
        getArbInfoAddress(),
        code,
        evmJumpTable,
        initCodePt,
        getArbInfoStorage()
    )?;
    asm(304,) { debugprint };

    // set up precompiled contracts
    acctStore = precompiles_init(acctStore)?;

    asm(305,) { debugprint };
    setGlobalAccountStore(acctStore);
    asm(306,) { debugprint };
    return Some(());
}

