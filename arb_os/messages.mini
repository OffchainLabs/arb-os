//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type ByteStream;
import type MarshalledBytes;
import type AccountStore;
import type Account;
import type EvmLogs;
import type StorageMap;

import impure func getGlobalAccountStore() -> AccountStore;
import impure func setGlobalAccountStore(acctStore: AccountStore);
import func accountStore_get(acctStore: AccountStore, addr: address) -> Account;
import func accountStore_set(acctStore: AccountStore, addr: address, acct: Account) -> AccountStore;
import func accountStore_transferEthBalance(
    acctStore: AccountStore,
    from: address, 
    to: address, 
    amount: uint
) -> option<AccountStore>;
import func accountStore_createAccountFromEvmCode(
    acctStore: AccountStore,
    newAddr: address,
    evmCode: ByteArray,
    evmJumpTable: map<uint, impure func()>,
    startCodePt: impure func(),
    storageMap: StorageMap
) -> option<AccountStore>;
import func account_checkAndIncrSeqNum(
    account: Account, 
    seqNumRecvd: uint
) -> option<Account>;
import func account_fetchAndIncrSeqNum(account: Account) -> (uint, Account);
import func account_addToEthBalance(account: Account, addition: uint) -> Account;
import func account_getStartCodePoint(acct: Account) -> option<impure func()>;

import impure func initEvmCallStack(
    callKind: uint,
    ethMessage: IncomingRequest,
    addr: address,
    caller: address,
    calldata: ByteArray,
    callvalue: uint,
    gas: uint,
    gasPrice: uint
);
import impure func initEvmCallStackForConstructor(
    ethMessage: IncomingRequest,
    addr: address,
    caller: address,
    code: ByteArray,
    evmJumpTable: map<uint, impure func()>,
    startPoint: impure func(),
    calldata: ByteArray,
    value: uint,
    gas: uint,
    gasPrice: uint
);
import func evmCallStack_runningCodeFromAccount() -> option<Account>;
import impure func emitLog(
    l1message: IncomingRequest,
    resultCode: uint,
    maybeReturnData: option<ByteArray>,
    maybeEvmLogs: option<EvmLogs>,
    gasUsed: uint,
    gasPrice: uint,
);

import impure func tokens_erc20deposit(
    tokenAddr: address,
    payee: address,
    amount: uint,
    msg: IncomingRequest
) -> option<()>;
import impure func tokens_erc721deposit(
    tokenAddr: address,
    payee: address,
    id: uint,
    msg: IncomingRequest
) -> option<()>;

import func bytearray_new(capacity: uint) -> ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes;

import func bytestream_new(ba: ByteArray) -> ByteStream;
import func bytestream_getByte(bs: ByteStream) -> option<(ByteStream, uint)>;
import func bytestream_get256(bs: ByteStream) -> option<(ByteStream, uint)>;
import func bytestream_skipBytes(bs: ByteStream, nbytes: uint) -> option<ByteStream>;
import func bytestream_getRemainingBytes(bs: ByteStream) -> ByteArray;

import func keccakOfRlpEncodedAddrUintPair(addr: address, ui: uint) -> bytes32;

import func translateEvmCodeSegment(bs: ByteStream) -> option<(impure func(), map<uint, impure func()>)>;


// This is the structure that the Arbitrum protocol gives us, for each incoming message.
// It is declared identically in inbox.mini
type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,          // sequence number in L1 inbox
    msgData: MarshalledBytes  // contents of the message, as a marshalled bytearray
}

public impure func handleIncomingRequest(
    msg: IncomingRequest,
    maxGas: uint,
    gasPrice: uint
) -> option<()> {   // return None if message format error; Some(()) if other error; if no error, never return
    // Parse an incoming message and do appropriate computations
    let inStream = bytestream_new(bytearray_unmarshalBytes(msg.msgData));

    if (msg.kind == 0) {
        // ethdeposit message
        let (bs, destination) = bytestream_get256(inStream)?;
        inStream = bs;

        let (bs, amount) = bytestream_get256(inStream)?;
        inStream = bs;

        let globalAS = getGlobalAccountStore();
        let destAccount = accountStore_get(globalAS, address(destination));
        destAccount = account_addToEthBalance(destAccount, amount);
        setGlobalAccountStore(
            accountStore_set(
                globalAS,
                address(destination),
                destAccount
            )
        );
        return Some(());
    } elseif (msg.kind == 1) {
        // ERC20 deposit message
        let (bs, tokenAddress) = bytestream_get256(inStream)?;
        inStream = bs;

        let (bs, payeeAddress) = bytestream_get256(inStream)?;
        inStream = bs;

        let (bs, amount) = bytestream_get256(inStream)?;
        inStream = bs;

        tokens_erc20deposit(
            address(tokenAddress),
            address(payeeAddress),
            amount,
            msg
        )?;  // should never return

        return None;
    } elseif (msg.kind == 2) {
         // ERC721 deposit message
         let (bs, tokenAddress) = bytestream_get256(inStream)?;
         inStream = bs;

         let (bs, payeeAddress) = bytestream_get256(inStream)?;
         inStream = bs;

         let (bs, id) = bytestream_get256(inStream)?;
         inStream = bs;

         tokens_erc721deposit(
             address(tokenAddress),
             address(payeeAddress),
             id,
             msg
         )?;  // should never return

         return None;
    } elseif (msg.kind == 3) {
        // L2 message
        handleL2Message(inStream, msg, maxGas, gasPrice)?;
        return Some(());
    } else {
        // not a valid message type
        return None;
    }
}

impure func verifyAndIncrSequenceNum(addr: address, seqNum: uint) -> option<()> {
    // Verify the sequence number on a message.
    // If it matches, increment the next expected seq num, and return Some(()).
    // Else, change nothing and return None.
    let globalAS = getGlobalAccountStore();
    setGlobalAccountStore(
        accountStore_set(
            globalAS,
            addr,
            account_checkAndIncrSeqNum(
                accountStore_get(globalAS, addr),
                seqNum
            )?
        )
    );
    return Some(());
}

impure func fetchAndIncrSequenceNum(addr: address) -> uint {
    // Fetch sequence number, and increment it
    let globalAS = getGlobalAccountStore();
    let (ret, updatedAcct) = account_fetchAndIncrSeqNum(
        accountStore_get(globalAS, addr)
    );
    setGlobalAccountStore(
        accountStore_set(
            globalAS,
            addr,
            updatedAcct
        )
    );
    return ret;
}

impure func handleL2Message(
    inStream: ByteStream,
    fullMsg: IncomingRequest,
    maxGas: uint,
    gasPrice: uint
) -> option<()> {   // return None if message is malformatted; otherwise handle errors and return Some(()); if no error, never return
    let (bs, msgType) = bytestream_getByte(inStream)?;
    inStream = bs;

    // skip maxGas and gasPriceBid fields of message
    inStream = bytestream_skipBytes(inStream, 64)?;

    let sequenceNum = (~0);  // impossible value for sequence number
    if (msgType == 0) {
        let(bs, sn) = bytestream_get256(inStream)?;
        inStream = bs;
        sequenceNum = sn;

        if (verifyAndIncrSequenceNum(fullMsg.sender, sequenceNum) == None<()>) {
            // bad sequence number error
            emitLog(fullMsg, 5, None<ByteArray>, None<EvmLogs>, 0, 0);
            return Some(());
        }
    }

    let (bs, calleeAddressAsUint) = bytestream_get256(inStream)?;
    inStream = bs;

    // Get value of Eth payment that accompanies the message.
    let value = 0;
    if ( (msgType==0) || (msgType==1) ) {
        let (bs, val) = bytestream_get256(inStream)?;
        inStream = bs;
        value = val;
    }

    if (calleeAddressAsUint == 0) {
        // this is a constructor call
        if (msgType == 2) {
            // revert error (tried to call constructor in a non-mutating call)
            emitLog(fullMsg, 1, None<ByteArray>, None<EvmLogs>, 0, 0);
            return Some(());
        }
        let codeBytes = bytestream_getRemainingBytes(inStream);
        let (codept, evmJumpTable) = translateEvmCodeSegment(bytestream_new(codeBytes))?;

        if (sequenceNum == (~0)) {
            sequenceNum = fetchAndIncrSequenceNum(fullMsg.sender);
        }
        let newAddress = address(keccakOfRlpEncodedAddrUintPair(fullMsg.sender, sequenceNum));

        initEvmCallStackForConstructor(
            fullMsg,
            newAddress,
            fullMsg.sender,
            codeBytes,
            evmJumpTable,
            codept,
            bytearray_new(0),   // no calldata for constructor call -- encoded args are packed into the code
            value,
            maxGas,
            gasPrice
        );  // should never return
    } else {
        // this is a non-constructor call
        let callKind = 0;
        if (msgType == 2) {
            callKind = 3;  // staticcall
        }

        let remainingCallData = bytestream_getRemainingBytes(inStream); // remaining bytes of message, to be passed to contract as calldata
        initEvmCallStack(
            callKind,
            fullMsg,
            address(calleeAddressAsUint),
            fullMsg.sender,
            remainingCallData,
            value,
            maxGas,
            gasPrice
        );  // should never return
    }

    panic;   // this should never be reached
}
