//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import type ByteStream;
import type MarshalledBytes;
import type AccountStore;
import type Account;
import type EvmLogs;

import impure func getGlobalAccountStore() -> AccountStore;
import impure func setGlobalAccountStore(acctStore: AccountStore);
import func accountStore_get(acctStore: AccountStore, addr: address) -> Account;
import func accountStore_set(acctStore: AccountStore, addr: address, acct: Account) -> AccountStore;
import func accountStore_transferEthBalance(
    acctStore: AccountStore,
    from: address, 
    to: address, 
    amount: uint
) -> option<AccountStore>;
import func accountStore_createAccountFromEvmCode(
    acctStore: AccountStore,
    newAddr: address,
    evmCode: ByteArray,
    evmJumpTable: map<uint, func()>,
    startCodePt: func(),
    storageMap: map<uint, uint>
) -> option<AccountStore>;
import func account_checkAndIncrSeqNum(
    account: Account, 
    seqNumRecvd: uint
) -> option<Account>;

import func account_getStartCodePoint(acct: Account) -> option<func()>;

import impure func initEvmCallStack(
    callKind: uint,
    ethMessage: MessageFromL1,
    addr: address,
    caller: address,
    calldata: ByteArray,
    callvalue: uint,
    gas: uint
);
import impure func initEvmCallStackForConstructor(
    ethMessage: MessageFromL1,
    addr: address,
    caller: address,
    code: ByteArray,
    evmJumpTable: map<uint, func()>,
    startPoint: func(),
    calldata: ByteArray,
    gas: uint
);
import func evmCallStack_runningCodeFromAccount() -> option<Account>;

import func tokens_erc20deposit(
    tokenAddr: address,
    payee: address,
    amount: uint,
    msg: MessageFromL1
) -> option<()>;

import func bytearray_new(capacity: uint) -> ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes;

import func bytestream_new(ba: ByteArray) -> ByteStream;
import func bytestream_getByte(bs: ByteStream) -> option<(ByteStream, uint)>;
import func bytestream_getUint(bs: ByteStream) -> option<(ByteStream, uint)>;
import func bytestream_getRemainingBytes(bs: ByteStream) -> ByteArray;

import func translateEvmCodeSegment(bs: ByteStream) -> option<(func(), map<uint, func()>)>;


// This is the structure that the Arbitrum protocol gives us, for each incoming message.
// It is declared identically in inbox.mini
type MessageFromL1 = struct {
    blockHash: bytes32,       // hash of the L1 block where this message was recorded
    timestamp: uint,          // timestamp of the L1 block
    blockNumber: uint,        // block number of the L1 block
    sender: address,          // address of the sender
    msgData: MarshalledBytes  // contents of the message, as a marshalled bytearray
}

public impure func handleMessageFromL1(msg: MessageFromL1) -> option<()> {
    // Parse an incoming message and do appropriate computations

    let inStream = bytestream_new(bytearray_unmarshalBytes(msg.msgData));

    let (bs, msgType) = bytestream_getByte(inStream)?;  // get message type
    inStream = bs;

    if (msgType == 0) {
        // txcall message
        let (bs, sequenceNum) = bytestream_getUint(inStream)?;
        inStream = bs;
        verifyAndIncrSequenceNum(msg.sender, sequenceNum)?;
        return handleValidTxMessage(inStream, msg, true);
    } elseif (msgType == 1) {
        // ethtransfer message

        let (bs, destination) = bytestream_getUint(inStream)?;
        inStream = bs;

        let (bs, amount) = bytestream_getUint(inStream)?;
        inStream = bs;

        setGlobalAccountStore(
            accountStore_transferEthBalance(
                getGlobalAccountStore(),
                msg.sender,
                address(destination),
                amount
            )?
        );
        return Some(());
    } elseif (msgType == 2) {
        // ERC20 deposit message
        let (bs, tokenAddress) = bytestream_getUint(inStream)?;
        inStream = bs;

        let (bs, payeeAddress) = bytestream_getUint(inStream)?;
        inStream = bs;

        let (bs, amount) = bytestream_getUint(inStream)?;
        inStream = bs;

        tokens_erc20deposit(
            address(tokenAddress),
            address(payeeAddress),
            amount,
            msg
        )?;  // should never return

        return None;
    } elseif (msgType == 3) {
        // ERC721 token transfer message
        return None; // NOT YET IMPLEMENTED
    } elseif (msgType == 4) {
        // contract txcall message (just like a normal txcall, but this doesn't have a sequence number)
        return handleValidTxMessage(inStream, msg, true);
    } elseif (msgType == 5) {
        // (non-mutating) call message
        return handleValidTxMessage(inStream, msg, false);
    } elseif (msgType == 6) {
        // EVM constructor/code upload message
        asm(600,) { debugprint };
        let (bs, sequenceNum) = bytestream_getUint(inStream)?;
        inStream = bs;
        verifyAndIncrSequenceNum(msg.sender, sequenceNum)?;

        asm(601,) { debugprint };
        let codeBytes = bytestream_getRemainingBytes(bs);
        let (codept, evmJumpTable) = translateEvmCodeSegment(bytestream_new(codeBytes))?;

        asm(602,) { debugprint };
        // Generate an address for the new contract.  //TODO: Switch this to use the same method as Ethereum.
        let newAddress = address(hash(bytes32(msg.sender), bytes32(sequenceNum)));

        asm(603,) { debugprint };
        initEvmCallStackForConstructor(
            msg,
            newAddress,
            msg.sender,
            codeBytes,
            evmJumpTable,
            codept,
            bytearray_new(0),   // no arguments to the call -- they're packed into the code
            1000000000000,            //TODO: limit gas used by constructor
        );  // should never return
        return None;
    } elseif (msgType == 7) {
        // EVM code load message -- this is deprecated
        let (bs, contractAddressAsUint) = bytestream_getUint(inStream)?;
        inStream = bs;

        let (storageMap, bs) = parseStorageMap(inStream)?;
        inStream = bs;

        let codeBytes = bytestream_getRemainingBytes(inStream);
        let (codept, evmJumpTable) = translateEvmCodeSegment(bytestream_new(codeBytes))?;
        setGlobalAccountStore(
            accountStore_createAccountFromEvmCode(
                getGlobalAccountStore(),
                address(contractAddressAsUint),
                codeBytes,
                evmJumpTable,
                codept,
                storageMap
            )?
        );
        return Some(());
    } else {
        // not a valid message type
        return None;
    }
}

impure func verifyAndIncrSequenceNum(addr: address, seqNum: uint) -> option<()> {
    // Verify the sequence number on a message.
    // If it matches, increment the next expected seq num, and return Some(()).
    // Else, change nothing and return None.
    let globalAS = getGlobalAccountStore();
    setGlobalAccountStore(
        accountStore_set(
            globalAS,
            addr,
            account_checkAndIncrSeqNum(
                accountStore_get(globalAS, addr),
                seqNum
            )?
        )
    );
    return Some(());
}

func parseStorageMap(bs: ByteStream) -> option<(map<uint, uint>, ByteStream)> {
    // Parse the structure used to convey initial storage contents, and initialize a map.
    // This is used only from a deprecated message type.
    let storageMap = newmap<uint, uint>;
    loop {
        let (ubs, more) = bytestream_getByte(bs)?;
        bs = ubs;
        if (more == 0) {
            return Some((storageMap, bs));
        }
        let (ubs, offset) = bytestream_getUint(bs)?;
        bs = ubs;
        let (ubs, value) = bytestream_getUint(bs)?;
        bs = ubs;
        storageMap = storageMap with { [offset] = value };
    }
}

impure func handleValidTxMessage(inStream: ByteStream, fullMsg: MessageFromL1, isMutating: bool) -> option<()> {
    let (bs, calleeAddressAsUint) = bytestream_getUint(inStream)?;
    inStream = bs;

    // Get value of Eth payment that accompanies the message.
    let value = 0;
    if (isMutating) {
        let (bs, val) = bytestream_getUint(inStream)?;
        inStream = bs;
        value = val;
    }

    // Get max ArbGas limit requested by user
    let (bs, maxGas) = bytestream_getUint(inStream)?;
    inStream = bs;

    // Get gas price bid submitted by user
    let gasPriceBid = 0;
    if (isMutating) {
        let (bs, gpb) = bytestream_getUint(inStream)?;
        inStream = bs;
        gasPriceBid = gpb;
    }

    let callKind = 3;  // staticcall
    if (isMutating) {
        callKind = 0;  // call
    }

    initEvmCallStack(
        callKind,
        fullMsg,
        address(calleeAddressAsUint),
        fullMsg.sender,
        bytestream_getRemainingBytes(inStream),  // remaining bytes of message passed to contract as calldata
        value,
        maxGas,
    );  // should never return

    return None;
}
