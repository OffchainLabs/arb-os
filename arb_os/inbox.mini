//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

import type ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes;
import func bytearray_get64(ba: ByteArray, offset: uint) -> uint;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_setByte(ba: ByteArray, offset: uint, value: uint) -> ByteArray;
import func bytearray_extract(ba: ByteArray, offset: uint, nbytes: uint) -> ByteArray;
import type MarshalledBytes;
import func marshalledBytes_firstByte(mb: MarshalledBytes) -> uint;

import type Queue;
import func queue_new() -> Queue;
import func queue_isEmpty(q: Queue) -> bool;
import func queue_get(q: Queue) -> option<(Queue, any)>;
import func queue_peek(q: Queue) -> option<any>;
import func queue_put(q: Queue, val: any) -> Queue;
import func queue_discardOneIfNonempty(q: Queue) -> option<Queue>;


import impure func chainParams_gotParamsMessage(sender: address, data: MarshalledBytes);
import impure func chainParams_chainId() -> uint;

import type MessageBatch;
import func messageBatch_tryNew(msg: IncomingRequest) -> option<MessageBatch>;
import func messageBatch_get(batch: MessageBatch) -> option<(IncomingRequest, MessageBatch)>;

import impure func outputStats_endOfBlock(blockNum: uint, timestamp: uint);

import type ByteArray;
import type MarshalledBytes;
import func marshalledBytes_firstByte(mb: MarshalledBytes) -> uint;
import func marshalledBytes_hash(mb: MarshalledBytes) -> bytes32;
import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytearray_new(capacityHint: uint) -> ByteArray;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;

import type ByteStream;
import func bytestream_new(ba: ByteArray) -> ByteStream;
import func bytestream_getByte(bs: ByteStream) -> option<(ByteStream, uint)>;
import func bytestream_get256(bs: ByteStream) -> option<(ByteStream, uint)>;
import func bytestream_getRemainingBytes(bs: ByteStream) -> ByteArray;

import func hashUnsignedL2messageInfo(l2msg: MarshalledBytes, chainId: uint, sender: address) -> bytes32;
import func translateSignedTx(req: IncomingRequest) -> option<TxRequestData>;

type Inbox = struct {
    readyQueue: Queue,     // Queue of requests that are ready to execute
    sequencerInfo: option<SequencerInfo>, // Sequencer info, or None if there isn't one
    lastBlockNum: uint,    // block number of last message returned by inbox_get
    lastTimestamp: uint,   // timestamp of last message returned by inbox_get
    needToPeek: bool, // true iff we should be doing an inboxpeek before inbox instruction
}

// If there is a slow lane, the idea is that messages from one address, the "fastLaneOwner",
//     get processed right away, and messages from everyone else get put in a slow lane queue.
// Messages in the slow lane queue are delayed by some number of block times (blocksOfDelay),
//     and they're re-tagged with the delayed block time.
// Messages are guaranteed to be produced by inbox_get in block-number order (after re-tagging).

type SequencerInfo = struct {
    sequencerAddr: address,
    blocksOfDelay: uint,
    delayQueue: Queue,
}

var globalInbox: Inbox;
var globalQueueFromBatch: Queue;

public impure func inbox_init() {
    globalInbox = struct {
        readyQueue: queue_new(),
        sequencerInfo: None<SequencerInfo>,
        lastBlockNum: 0,
        lastTimestamp: 0,
        needToPeek: false,   // don't peek before the first message
    };
    globalQueueFromBatch = queue_new();
}

public impure func inbox_startSequencer(sequencerAddr: address, blocksOfDelay: uint) -> option<()> {
    if (globalInbox.sequencerInfo == None<SequencerInfo>) {
        globalInbox = globalInbox with {
            sequencerInfo: Some(struct {
                sequencerAddr: sequencerAddr,
                blocksOfDelay: blocksOfDelay,
                delayQueue: queue_new()
            })
        };
        return Some(());
    } else {
        return None;
    }
}

public impure func inbox_get() -> IncomingRequest {
   // Get the next message, in order of arrival.
    // If no messages have arrived, this will block until one arrives.
    // This is a loop because some events don't generate a message that we can return,
    //       so we keep trying until we find something we can return.

    loop {
        while (queue_isEmpty(globalInbox.queue)) {
            if let Some(seqInfo) = globalInbox.sequencerInfo {
               let (uq, useq) = getFromSequencer(globalInbox.readyQueue, getFromL1Inbox(queue_new()), seqInfo);
                globalInbox = globalInbox with {
                    readyQueue: uq
                } with {
                    sequencerInfo: Some(useq)
                };
            } else {
                globalInbox = getFromL1Inbox(globalInbox);
            }
        }

        let (updatedQ, ret,) = queueGetOrDie(globalInbox.queue);
        globalInbox = globalInbox with { queue: updatedQ };
        let ebMsg = unsafecast<IncomingRequest>(ret);
        if (ebMsg.kind == 4) {
            chainParams_gotParamsMessage(ebMsg.sender, ebMsg.msgData);
            if let Some(seqInfo) = globalInbox.sequencerInfo {
                // We just set up a sequencer.
                // Any messages in the readyQueue need to be fed through the sequencer.
                let (uq, useq) = getFromSequencer(queue_new(), globalInbox.readyQueue, seqInfo);
                globalInbox = globalInbox with {
                    readyQueue: uq
                } with {
                    sequencerInfo: Some(useq)
                };
            }
        } else {
            return ebMsg with {
                requestId: uint(hash(bytes32(chainParams_chainId()), bytes32(ebMsg.requestId)))
            };
        }
    }
}

impure func getFromSequencer(qToFill: Queue, inQ: Queue, seqInfo: SequencerInfo) -> (Queue, SequencerInfo) {
    // push one or more messages into qToFill
    while ( ! queue_isEmpty(inQ) ) {
        let (uq, rawMsg) = queueGetOrDie(inQ);
        inQ = uq;
        let inMsg = unsafecast<IncomingRequest>(rawMsg);

        // release messages that have aged out of the delay queue
        let releasePoint = 0;
        if (inMsg.blockNumber > seqInfo.blocksOfDelay) {
            releasePoint = inMsg.blockNumber - seqInfo.blocksOfDelay;
        }
        if let Some(res) = releaseFromQueueByBlockNum(
            seqInfo.delayQueue,
            qToFill,
            seqInfo.blocksOfDelay,
            releasePoint,
            inMsg.blockNumber,
            inMsg.timestamp
        ) {
            let (uDelayQ, uFillQ) = res;
            seqInfo = seqInfo with { delayQueue: uDelayQ };
            qToFill = uFillQ;
        }

        if (inMsg.sender != seqInfo.sequencerAddr) {
            // message not from sequencer, put it in delay queue
            seqInfo = seqInfo with { delayQueue: queue_put(seqInfo.delayQueue, inMsg) };
        } elseif ( (inMsg.kind == 3) && (marshalledBytes_firstByte(inMsg.msgData) == 5) ) {
            // sequencer batch message needs special handling

            let ba = bytearray_unmarshalBytes(inMsg.msgData);

            // release any additional delayQueue messages it authorizes
            let releasePoint = bytearray_get64(ba, 1);
            if let Some(res) = releaseFromQueueByBlockNum(
                seqInfo.delayQueue,
                qToFill,
                seqInfo.blocksOfDelay,
                releasePoint,
                inMsg.blockNumber,
                inMsg.timestamp
            ) {
                let (uSlowQ, uFillQ) = res;
                seqInfo = seqInfo with { delayQueue: uSlowQ };
                qToFill = uFillQ;
            }

            // now morph this into a normal batch message
            // strip 64 bytes off of fastMsg's L2 data, then set first byte to 3
            inMsg = inMsg with {
                msgData: bytearray_marshalFull(
                    bytearray_setByte(
                        bytearray_extract(ba, 8, bytearray_size(ba)-8),
                        0,
                        3  // typecode for a normal batch message
                    )
                )
            };
            qToFill = queue_put(qToFill, inMsg);
        } else {
            qToFill = queue_put(qToFill, inMsg);
       }
    }

    return (qToFill, seqInfo);
}

func releaseFromQueueByBlockNum(
    inQueue: Queue,
    outQueue: Queue,
    maxDelay: uint,             // maximum blocks of delay to impose on any message
    blockNumToRelease: uint,    // release messages this old, or older
    knownBlockNumber: uint,     // most recent known block number
    knownTimestamp: uint,       // most recent known timestamp
) -> option<(Queue, Queue)> {
    let anyChange = false;
    let moreToDo = true;
    while (moreToDo && !queue_isEmpty(inQueue)) {
        let nextMsg = unsafecast<IncomingRequest>(queue_peek(inQueue)?);   // won't return None because we know queue is nonempty
        if (nextMsg.blockNumber <= blockNumToRelease) {
            anyChange = true;
            let assignBlockNum = knownBlockNumber;
            let assignTimestamp = knownTimestamp;
            if (assignBlockNum > (nextMsg.blockNumber + maxDelay)) {
                assignTimestamp = linearInterpolate(
                    nextMsg.blockNumber,
                    nextMsg.timestamp,
                    knownBlockNumber,
                    knownTimestamp,
                    nextMsg.blockNumber+maxDelay
                );
                assignBlockNum = nextMsg.blockNumber + maxDelay;
            }
            nextMsg = nextMsg with {
                blockNumber: assignBlockNum
            } with {
                timestamp: assignTimestamp
            };
            outQueue = queue_put(outQueue, nextMsg);
            if let Some(inq) = queue_discardOneIfNonempty(inQueue) {
                inQueue = inq;
            }
        } else {
            moreToDo = false;
        }
    }
    if (anyChange) {
        return Some((inQueue, outQueue));
    } else {
        return None;
    }
}

func linearInterpolate(x1: uint, y1: uint, x2: uint, y2: uint, x: uint) -> uint {
    if (x1 == x2) {
        return y1;
    } else {
        return y1 + (x-x1)*(y2-y1)/(x2-x1);
    }
}

func queueGetOrDie(q: Queue) -> (Queue, any) {
    if let Some(res) = queue_get(q) {
        return res;
    } else {
        panic;
    }
}

impure func getFromL1Inbox(inbox: Inbox) -> Inbox {
    // Get a message from the L1 inbox, and append it to the inbox.
    // If there are no messages available in the L1 inbox, this blocks until one is available.
    if (inbox.needToPeek) {
        let sameBlockNum = asm(inbox.blockNum,) bool { inboxpeek };
        if ( ! sameBlockNum) {
            // peek says we hit end of L1 block, so insert end-of-block message and return
            return inbox with {
                queue: queue_put(
                    inbox.queue,
                    struct {
                        kind: 6,   // special kind that is reserved for these synthetic end-of-block messages
                        blockNumber: inbox.blockNum,
                        timestamp: inbox.timestamp,
                        sender: address(0),
                        requestId: 0,
                        msgData: unsafecast<MarshalledBytes>(0),
                    }
                )
            } with {
                needToPeek: false   // don't peek next time, because we already sent end-of-block
            };
        }
    }
    let newMsg = asm() IncomingRequest { inbox };

    if (newMsg.blockNumber == 0) {
        newMsg = newMsg with { blockNumber: inbox.blockNum };
    }
    if (newMsg.timestamp == 0) {
        newMsg = newMsg with { timestamp: inbox.timestamp };
    }

    return inbox with {
        queue: queue_put(inbox.queue, newMsg)
    } with {
        needToPeek: true
    } with {
        blockNum: newMsg.blockNumber
    } with {
        timestamp: newMsg.timestamp
    };
}

public impure func inbox_currentBlockNumber() -> uint {
    return globalInbox.lastBlockNum;
}

public impure func inbox_currentTimestamp() -> uint {
    
    return globalInbox.lastTimestamp;
}
// This structure describes an incoming request.
// It is declared identically in inbox.mini and elsewhere
type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,
    msgData: MarshalledBytes  // kind-specific data, as a marshalled bytearray
}

// TxRequestData is declared identically in message.mini and elsewhere.
type TxRequestData = struct {
    maxGas: uint,
    gasPrice: uint,
    seqNum: option<uint>,
    caller: address,
    calleeAddr: address,
    value: uint,
    calldata: ByteArray,
    incomingRequest: IncomingRequest,
}

public impure func inbox_getNextUnpackedRequest() -> (
    option<IncomingRequest>,  // if it was an L1 message
    option<TxRequestData>,    // if it was an L2 tx message
) {
    let msg = unsafecast<IncomingRequest>(());   // value will be re-initialized before use
    loop {
        if let Some(res) = queue_get(globalQueueFromBatch) {
            let (newQ, rawMsg) = res;
            globalQueueFromBatch = newQ;
            msg = unsafecast<IncomingRequest>(rawMsg);
        } else {
            msg = inbox_get();
        }

        if let Some(batch) = messageBatch_tryNew(msg) {
            // it's a batch message, so unpack its components and queue them
            let moreToDo = true;
            let queue = globalQueueFromBatch;
            while (moreToDo) {
                if let Some(res) = messageBatch_get(batch) {
                    let (newMsg, restOfBatch) = res;
                    queue = queue_put(queue, newMsg);
                    batch = restOfBatch;
                } else {
                    moreToDo = false;
                }
            }
            globalQueueFromBatch = queue;
        } else {
            // it's not a batch, so process it immediately
            // get its maxGas amount -- for now, set the limit high, unless caller asked for less
            let maxGas = 1000000000;
            if (msg.kind == 6) {
                // it's an end-of-block message, so just trigger end-of-block processing
                outputStats_endOfBlock(msg.blockNumber, msg.timestamp);
            } elseif (msg.kind == 3) {
                // it's an L2 message, so switch based on the L2 type
                let firstByte = marshalledBytes_firstByte(msg.msgData);
                if (firstByte == 6) {
                    // it's a heartbeat message, don't do anything
                } elseif (firstByte == 4) {
                    // it's a signed tx; verify sig and then process request or discard
                    if let Some(txRequest) = translateSignedTx(msg) {
                        return (None<IncomingRequest>, Some(txRequest));
                    }
                    // else signature was invalid, ignore msg and execute loop again to get another
                } else {
                    // subtype must be 0, 1, or 2
                    if let Some(txRequest) = translateUnsignedTx(msg) {
                        return (None<IncomingRequest>, Some(txRequest));
                    }
                    // else request was malformatted, ignore it and execute loop again to get another
                }
            } elseif (msg.kind == 5) {
                if let Some(txRequest) = translateBuddyDeployTx(msg) {
                    return (None<IncomingRequest>, Some(txRequest));
                }
                // else request was malformatted, ignore it and execute loop again to get another
            } else {
                return (Some(msg), None<TxRequestData>);
            }
        }
    }
}

func translateUnsignedTx(request: IncomingRequest) -> option<TxRequestData> {
    let inStream = bytestream_new(bytearray_unmarshalBytes(request.msgData));
    let (us, subtype) = bytestream_getByte(inStream)?;
    inStream = us;

    let (us, maxGas) = bytestream_get256(inStream)?;
    inStream = us;

    let (us, gasPrice) = bytestream_get256(inStream)?;
    inStream = us;

    let seqNum = None<uint>;
    if (subtype == 0) {
        let (us, sn) = bytestream_get256(inStream)?;
        inStream = us;
        seqNum = Some(sn);
    }

    let (us, destAddrAsUint) = bytestream_get256(inStream)?;
    inStream = us;

    let value = 0;
    if (subtype != 2) {
        let (us, val) = bytestream_get256(inStream)?;
        inStream = us;
        value = val;
    }

    let calldata = bytestream_getRemainingBytes(inStream);

    if (subtype == 0) {
        request = request with {
            requestId: uint(hash(
                bytes32(request.sender),
                hash(
                    bytes32(chainParams_chainId()),
                    marshalledBytes_hash(request.msgData)
                )
            ))
        };
    }
    return Some(
        struct {
            maxGas: maxGas,
            gasPrice: gasPrice,
            seqNum: seqNum,
            caller: request.sender,
            calleeAddr: address(destAddrAsUint),
            value: value,
            calldata: calldata,
            incomingRequest: request
        }
    );
}

func translateBuddyDeployTx(request: IncomingRequest) -> option<TxRequestData> {
    let inStream = bytestream_new(bytearray_unmarshalBytes(request.msgData));

    let (us, maxGas) = bytestream_get256(inStream)?;
    inStream = us;

    let (us, gasPrice) = bytestream_get256(inStream)?;
    inStream = us;

    let (us, value) = bytestream_get256(inStream)?;
    inStream = us;

    let calldata = bytestream_getRemainingBytes(inStream);

    return Some(
        struct {
            maxGas: maxGas,
            gasPrice: gasPrice,
            seqNum: None<uint>,
            caller: request.sender,
            calleeAddr: address(0),
            value: value,
            calldata: calldata,
            incomingRequest: request
        }
    );
}

