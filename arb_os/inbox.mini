//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes;
import func bytearray_get64(ba: ByteArray, offset: uint) -> uint;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_setByte(ba: ByteArray, offset: uint, value: uint) -> ByteArray;
import func bytearray_extract(ba: ByteArray, offset: uint, nbytes: uint) -> ByteArray;
import type MarshalledBytes;
import func marshalledBytes_firstByte(mb: MarshalledBytes) -> uint;

import type Queue;
import func queue_new() -> Queue;
import func queue_isEmpty(q: Queue) -> bool;
import func queue_get(q: Queue) -> option<(Queue, any)>;
import func queue_peek(q: Queue) -> option<any>;
import func queue_put(q: Queue, val: any) -> Queue;
import func queue_discardOneIfNonempty(q: Queue) -> option<Queue>;


import impure func chainParams_gotParamsMessage(sender: address, data: MarshalledBytes);

import type MarshalledBytes;

// This is the structure that the Arbitrum protocol gives us, for each incoming message.
// It is declared identically in messages.mini
type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,          // sequence number in L1 inbox
    msgData: MarshalledBytes  // contents of the message, as a marshalled bytearray
}

type Inbox = struct {
    readyQueue: Queue,     // Queue of requests that are ready to execute
    sequencerInfo: option<SequencerInfo>, // Sequencer info, or None if there isn't one
    lastBlockNum: uint,    // block number of last message returned by inbox_get
    lastTimestamp: uint,   // timestamp of last message returned by inbox_get
}

// If there is a slow lane, the idea is that messages from one address, the "fastLaneOwner",
//     get processed right away, and messages from everyone else get put in a slow lane queue.
// Messages in the slow lane queue are delayed by some number of block times (blocksOfDelay),
//     and they're re-tagged with the delayed block time.
// Messages are guaranteed to be produced by inbox_get in block-number order (after re-tagging).

type SequencerInfo = struct {
    sequencerAddr: address,
    blocksOfDelay: uint,
    delayQueue: Queue,
}

var globalInbox: Inbox;

public impure func inbox_init() {
    globalInbox = struct {
        readyQueue: queue_new(),
        sequencerInfo: None<SequencerInfo>,
        lastBlockNum: 0,
        lastTimestamp: 0,
    };
}

public impure func inbox_startSequencer(sequencerAddr: address, blocksOfDelay: uint) -> option<()> {
    if (globalInbox.sequencerInfo == None<SequencerInfo>) {
        globalInbox = globalInbox with {
            sequencerInfo: Some(struct {
                sequencerAddr: sequencerAddr,
                blocksOfDelay: blocksOfDelay,
                delayQueue: queue_new()
            })
        };
        return Some(());
    } else {
        return None;
    }
}

public impure func inbox_get() -> IncomingRequest {
    // Get the next message, in order of arrival (possibly modified due to sequencer rules).
    // If no messages are ready, this will block until one is ready.

    loop {
        if let Some(res) = queue_get(globalInbox.readyQueue) {
            let (updatedQ, msg) = res;
            let ebMsg = unsafecast<IncomingRequest>(msg);
            globalInbox = globalInbox
                with { readyQueue: updatedQ }
                with { lastBlockNum: ebMsg.blockNumber }
                with { lastTimestamp: ebMsg.timestamp };
            if (ebMsg.kind == 4) {
                chainParams_gotParamsMessage(ebMsg.sender, ebMsg.msgData);
                if let Some(seqInfo) = globalInbox.sequencerInfo {
                    // We just set up a sequencer.
                    // Any messages in the readyQueue need to be fed through the sequencer.
                    let (uq, useq) = getFromSequencer(queue_new(), globalInbox.readyQueue, seqInfo);
                    globalInbox = globalInbox with {
                        readyQueue: uq
                    } with {
                        sequencerInfo: Some(useq)
                    };
                }
            } else {
                return ebMsg;
            }
        } else {
            if let Some(seqInfo) = globalInbox.sequencerInfo {
                let (uq, useq) = getFromSequencer(globalInbox.readyQueue, getFromL1Inbox(queue_new()), seqInfo);
                globalInbox = globalInbox with {
                    readyQueue: uq
                } with {
                    sequencerInfo: Some(useq)
                };
            } else {
                let q = globalInbox.readyQueue;
                while (queue_isEmpty(q)) {
                    q = getFromL1Inbox(q);
                }
                globalInbox = globalInbox with { readyQueue: q };
            }
        }
    }
}

impure func getFromSequencer(qToFill: Queue, inQ: Queue, seqInfo: SequencerInfo) -> (Queue, SequencerInfo) {
    // push one or more messages into qToFill
    while ( ! queue_isEmpty(inQ) ) {
        let (uq, rawMsg) = queueGetOrDie(inQ);
        inQ = uq;
        let inMsg = unsafecast<IncomingRequest>(rawMsg);

        // release messages that have aged out of the delay queue
        let releasePoint = 0;
        if (inMsg.blockNumber > seqInfo.blocksOfDelay) {
            releasePoint = inMsg.blockNumber - seqInfo.blocksOfDelay;
        }
        if let Some(res) = releaseFromQueueByBlockNum(
            seqInfo.delayQueue,
            qToFill,
            seqInfo.blocksOfDelay,
            releasePoint,
            inMsg.blockNumber,
            inMsg.timestamp
        ) {
            let (uDelayQ, uFillQ) = res;
            seqInfo = seqInfo with { delayQueue: uDelayQ };
            qToFill = uFillQ;
        }

        if (inMsg.sender != seqInfo.sequencerAddr) {
            // message not from sequencer, put it in delay queue
            seqInfo = seqInfo with { delayQueue: queue_put(seqInfo.delayQueue, inMsg) };
        } elseif ( (inMsg.kind == 3) && (marshalledBytes_firstByte(inMsg.msgData) == 5) ) {
            // sequencer batch message needs special handling

            let ba = bytearray_unmarshalBytes(inMsg.msgData);

            // release any additional delayQueue messages it authorizes
            let releasePoint = bytearray_get64(ba, 1);
            if let Some(res) = releaseFromQueueByBlockNum(
                seqInfo.delayQueue,
                qToFill,
                seqInfo.blocksOfDelay,
                releasePoint,
                inMsg.blockNumber,
                inMsg.timestamp
            ) {
                let (uSlowQ, uFillQ) = res;
                seqInfo = seqInfo with { delayQueue: uSlowQ };
                qToFill = uFillQ;
            }

            // now morph this into a normal batch message
            // strip 64 bytes off of fastMsg's L2 data, then set first byte to 3
            inMsg = inMsg with {
                msgData: bytearray_marshalFull(
                    bytearray_setByte(
                        bytearray_extract(ba, 8, bytearray_size(ba)-8),
                        0,
                        3  // typecode for a normal batch message
                    )
                )
            };
            qToFill = queue_put(qToFill, inMsg);
        } else {
            qToFill = queue_put(qToFill, inMsg);
        }
    }

    return (qToFill, seqInfo);
}

func releaseFromQueueByBlockNum(
    inQueue: Queue,
    outQueue: Queue,
    maxDelay: uint,             // maximum blocks of delay to impose on any message
    blockNumToRelease: uint,    // release messages this old, or older
    knownBlockNumber: uint,     // most recent known block number
    knownTimestamp: uint,       // most recent known timestamp
) -> option<(Queue, Queue)> {
    let anyChange = false;
    let moreToDo = true;
    while (moreToDo && !queue_isEmpty(inQueue)) {
        let nextMsg = unsafecast<IncomingRequest>(queue_peek(inQueue)?);   // won't return None because we know queue is nonempty
        if (nextMsg.blockNumber <= blockNumToRelease) {
            anyChange = true;
            let assignBlockNum = knownBlockNumber;
            let assignTimestamp = knownTimestamp;
            if (assignBlockNum > (nextMsg.blockNumber + maxDelay)) {
                assignTimestamp = linearInterpolate(
                    nextMsg.blockNumber,
                    nextMsg.timestamp,
                    knownBlockNumber,
                    knownTimestamp,
                    nextMsg.blockNumber+maxDelay
                );
                assignBlockNum = nextMsg.blockNumber + maxDelay;
            }
            nextMsg = nextMsg with {
                blockNumber: assignBlockNum
            } with {
                timestamp: assignTimestamp
            };
            outQueue = queue_put(outQueue, nextMsg);
            if let Some(inq) = queue_discardOneIfNonempty(inQueue) {
                inQueue = inq;
            }
        } else {
            moreToDo = false;
        }
    }
    if (anyChange) {
        return Some((inQueue, outQueue));
    } else {
        return None;
    }
}

func linearInterpolate(x1: uint, y1: uint, x2: uint, y2: uint, x: uint) -> uint {
    if (x1 == x2) {
        return y1;
    } else {
        return y1 + (x-x1)*(y2-y1)/(x2-x1);
    }
}

func queueGetOrDie(q: Queue) -> (Queue, any) {
    if let Some(res) = queue_get(q) {
        return res;
    } else {
        panic;
    }
}

// InboxCell is the structure that the Arbitrum protocol uses to combine multiple messages
//     when they arrive in the inbox together.
// This is basically a linked list, but in reverse order (newest message at head of list).
type InboxCell = struct {
    rest: any,   // really an InboxCell, but language doesn't allow recursive types
    msg: any,
}

impure func getFromL1Inbox(queue: Queue) -> Queue {
    // Get one or more messages from the L1 inbox, and append them to the queue.
    // If there are no messages available in the L1 inbox, this blocks until one is available.
    let newMsgs = asm() InboxCell { inbox };
    queue = addInboxToQueue(queue, newMsgs);
    return queue;
}

func addInboxToQueue(queue: Queue, newMsgs: InboxCell) -> Queue {
    // Unpack messages from an InboxCell list, and append them to an Inbox.
    // Because the messages are in the linked list in newest-first order, we need to reverse the order.
    if (unsafecast<any>(newMsgs) == null) {
        return queue;
    } else {
        queue = addInboxToQueue(queue, unsafecast<InboxCell>(newMsgs.rest));
        return queue_put(queue, newMsgs.msg);
    }
}

public impure func inbox_currentBlockNumber() -> uint {
    return globalInbox.lastBlockNum;
}

public impure func inbox_currentTimestamp() -> uint {
    return globalInbox.lastTimestamp;
}