//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type MarshalledBytes;
import type ByteArray;
import type ByteStream;

import func bytearray_unmarshalBytes(mb: MarshalledBytes) -> ByteArray;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytestream_new(contents: ByteArray) -> ByteStream;
import func bytestream_skipBytes(bs: ByteStream, nbytes: uint) -> option<ByteStream>;
import func bytestream_get64(bs: ByteStream) -> option<(ByteStream, uint)>;
import func bytestream_get256(bs: ByteStream) -> option<(ByteStream, uint)>;

import func inbox_startSequencer(sequencerAddress: uint, blocksOfDelay: uint) -> option<()>;

import impure func errorHandler();


type ChainParams = struct {
    chainAddress: address,
    gracePeriodTicks: uint,
    arbGasSpeedLimit: uint,
    maxExecutionStepsPerAssertion: uint,
    stakeRequirement: uint,
    chainOwner: address,
}

var globalChainParams: option<ChainParams>;

public impure func chainParams_init() {
    globalChainParams = None<ChainParams>;
}

public impure func chainParams_gotParamsMessage(sender: address, data: MarshalledBytes) {
    if (globalChainParams == None<ChainParams>) {
        let payload = bytearray_unmarshalBytes(data);
        globalChainParams = Some(
            struct{
                chainAddress: sender,
                gracePeriodTicks: bytearray_get256(payload, 0),
                arbGasSpeedLimit: bytearray_get256(payload, 32),
                maxExecutionStepsPerAssertion: bytearray_get256(payload, 2*32),
                stakeRequirement: bytearray_get256(payload, 3*32),
                chainOwner: address(bytearray_get256(payload, 4*32))
            }
        );

        // now read and process initialization options
        if let Some(stream) = bytestream_skipBytes(bytestream_new(payload), 5*32) {
            loop {
                if let Some(ustr2) = doInitializationOption(stream) {
                    stream = ustr2;
                } else {
                    return;
                }
            }
        }
    }
}

func doInitializationOption(stream: ByteStream) -> option<ByteStream> {
    // process one initialization option
    // on success, return Some(updated stream)
    // on end-of-stream, return None

    let (ustr, optionId) = bytestream_get64(stream)?;
    stream = ustr;
    let (ustr, numPayloadBytes) = bytestream_get64(stream)?;
    stream = ustr;
    if (optionId == 1) {   // option: tx sequencer
        if (numPayloadBytes != 40) {
            return None;
        }
        let (ustr, sequencerAddress) = bytestream_get256(stream)?;
        stream = ustr;
        let (ustr, blocksOfDelay) = bytestream_get64(stream)?;
        stream = ustr;
        inbox_startSequencer(sequencerAddress, blocksOfDelay)?;
        return Some(stream);
    } else {
        // unrecognized option, discard it
        return bytestream_skipBytes(stream, numPayloadBytes);
    }
}

public impure func chainParams_chainAddress() -> address {
    if let Some(params) = globalChainParams {
        return params.chainAddress;
    } else {
        // If we get here, the chain never received its initialization message.
        errorHandler();
        panic;
    }
}

public impure func chainParams_chainId() -> uint {
    return uint(chainParams_chainAddress()) & 0xffffffffffff;  // chainID == low 48 bits of chainAddress
}