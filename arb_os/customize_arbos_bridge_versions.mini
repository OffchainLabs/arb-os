//
// Copyright 2021, Offchain Labs, Inc. All rights reserved.
//

use bridge_arbos_versions::GlobalsBeforeUpgrade;

use bridge_arbos_versions::before__accounts_Account;

use accounts::Account;
use accounts::AccountStore;
use accounts::AggregatorInfo;

use evmCallStack::EvmCallFrame;

use gasAccounting::GasAccountingInfo;

use tracing::EvmTracer;
use tracing::evmTracer_new;

use std::avmcodebuilder::AvmCodePoint;

use std::fixedpoint::fixedPoint_new;

use std::merkletree::MerkleTreeBuilder;

use gasAccounting::TxGasState;
use gasAccounting::FeeConfig;
use gasAccounting::GasPrices;
use gasAccounting::CongestionState;
use gasAccounting::PricingParameters;
use gasAccounting::RetryablePrices;

use std::addressSet::SetOfAddresses;
use std::addressSet::setOfAddresses_all;
use evmCallStack::EvmCallFrame;
use messages::TxRequestData;

use core::kvs::Kvs;
use core::kvs::builtin_kvsForall;


public func set_globalCallStack_onUpgrade(_oldGlobals: GlobalsBeforeUpgrade) -> option<EvmCallFrame> {
    return None<EvmCallFrame>;
}

public func set_gasAccountingInfo_onUpgrade(oldGlobals: GlobalsBeforeUpgrade) -> GasAccountingInfo {
    let oldInfo = oldGlobals.gasAccountingInfo;
    let oldPP = oldInfo.pricingParams;
    return struct {
        txState: oldInfo.txState,
        feeConfig: struct {
            baseFeeMultiplier: oldInfo.feeConfig.baseFeeMultiplier,
            shareForNetFee: oldInfo.feeConfig.shareForNetFee,
        },
        currentPrices: struct {
            perL1CalldataUnit: oldInfo.currentPrices.perL1CalldataUnit,
            perStorageCell: oldInfo.currentPrices.perStorageCell,
            perArbGasBase: oldInfo.currentPrices.perArbGasBase,
            perArbGasCongestion: oldInfo.currentPrices.perArbGasCongestion,
            perArbGasTotal: oldInfo.currentPrices.perArbGasTotal,
        },
        gasRemainingThisBlock: oldInfo.gasRemainingThisBlock,
        congestionState: oldInfo.congestionState,
        speedLimitPerSecond: oldInfo.speedLimitPerSecond,
        pricingParams: struct {
            l1GasPerL1CalldataUnit: oldPP.l1GasPerL1CalldataUnit,
            l1GasPerStorage: oldPP.l1GasPerStorage,
            arbGasDivisor: oldPP.arbGasDivisor,
        },
        gasAllocatedToThisBlock: oldInfo.gasAllocatedToThisBlock,
        retryablePrices: oldInfo.retryablePrices,
        allowedSenders: oldInfo.allowedSenders,
    };
}

public func set_globalChainParameters_onUpgrade(oldGlobals: GlobalsBeforeUpgrade) -> map<uint, uint> {
    let oldChainParams = xif let Some(cp) = oldGlobals.globalChainParams {
        cp
    } else {
        struct {
            chainId: const::Default_Param_ChainID,
            gracePeriodBlocks: const::Default_Param_ChallengePeriodEthBlocks,
            arbGasSpeedLimitPerSecond: const::Default_Param_SpeedLimitPerSecond,
            maxExecutionSteps: 1000000000000,  // never used
            baseStake: 5000000000,             // never used
            stakingToken: address(0),          // ETH
            owner: address(0),
            secondsPerSend: None<uint>,
            defaultAggregator: address(const::Default_Param_DefaultAggregator),
        }
    };

    return newmap<uint, uint>
        with { [const::Atom_Param_SecondsPerBlockNumerator] = const::Default_Param_SecondsPerBlockNumerator }
        with { [const::Atom_Param_SecondsPerBlockDenominator] = const::Default_Param_SecondsPerBlockDenominator }
        with { [const::Atom_Param_FeesEnabled] = xif (oldGlobals.gasAccountingInfo.feeConfig.enabled) { 1 } else { 0 } }
        with { [const::Atom_Param_NetworkFeeRecipient] = uint(oldGlobals.gasAccountingInfo.feeConfig.forNetwork) }
        with { [const::Atom_Param_CongestionFeeRecipient] = uint(oldGlobals.gasAccountingInfo.feeConfig.forCongestion) }
        with { [const::Atom_Param_DefaultAggregator] = uint(oldChainParams.defaultAggregator) }
        with { [const::Atom_Param_DefaultBaseTxFeeL1Gas] = const::Default_Param_DefaultBaseTxFeeL1Gas }
        with { [const::Atom_Param_MinBaseTxFeeL1Gas] = const::Default_Param_MinBaseTxFeeL1Gas }
        with { [const::Atom_Param_MaxBaseTxFeeL1Gas] = const::Default_Param_MaxBaseTxFeeL1Gas }
        with { [const::Atom_Param_ChainID] = oldChainParams.chainId }
        with { [const::Atom_Param_ChallengePeriodEthBlocks] = oldChainParams.gracePeriodBlocks }
        with { [const::Atom_Param_SpeedLimitPerSecond] = oldGlobals.gasAccountingParams.SpeedLimitPerSecond }
        with {
            [const::Atom_Param_SecondsPerSend] = xif let Some(sps) = oldChainParams.secondsPerSend {
                sps
            } else {
                const::Default_Param_SecondsPerSend
            }
        }
        with { [const::Atom_Param_ChainOwner] = uint(oldChainParams.owner) }
        with { [const::Atom_Param_L1GasPerL1CalldataUnit] = oldGlobals.gasAccountingInfo.pricingParams.l1GasPerL1CalldataUnit }
        with { [const::Atom_Param_L1GasPerStorage] = oldGlobals.gasAccountingInfo.pricingParams.l1GasPerStorage }
        with { [const::Atom_Param_ArbGasDivisor] = oldGlobals.gasAccountingInfo.pricingParams.arbGasDivisor }
        with {
            [const::Atom_Param_NetworkFeeShareNumerator] = {
                let bfm = oldGlobals.gasAccountingInfo.feeConfig.baseFeeMultiplier;
                bfm.val - bfm.shiftFactor
            }
        }
        with { [const::Atom_Param_NetworkFeeShareDenominator] = oldGlobals.gasAccountingInfo.feeConfig.baseFeeMultiplier.shiftFactor }
        with { [const::Atom_Param_GasPoolMax] = oldGlobals.gasAccountingParams.GasPoolMax }
        with { [const::Atom_Param_TxGasLimit] = oldGlobals.gasAccountingParams.TxGasLimit }
        with { [const::Atom_Param_RetryablePriceBase] = const::Default_Param_RetryablePriceBase }
        with { [const::Atom_Param_RetryablePricePerByteNumerator] = const::Default_Param_RetryablePricePerByteNumerator }
        with { [const::Atom_Param_RetryablePricePerByteDenominator] = const::Default_Param_RetryablePricePerByteDenominator }
        with { [const::Atom_Param_RetryableTxRepriceIntervalSeconds] = const::Default_Param_RetryableTxRepriceIntervalSeconds }
        with { [const::Atom_Param_L1GasPriceEstimateWeightNumerator] = const::Default_Param_L1GasPriceEstimateWeightNumerator }
        with { [const::Atom_Param_L1GasPriceEstimateWeightDenominator] = const::Default_Param_L1GasPriceEstimateWeightDenominator }
        with { [const::Atom_Param_RetryableTxLifetimeSeconds] = const::Default_Param_RetryableTxLifetimeSeconds }
        with { [const::Atom_Param_ArbitrumNonZeroBalanceCallStipend] = const::Default_Param_ArbitrumNonZeroBalanceCallStipend }
        with { [const::Atom_Param_GasPriceOracle] = const::Default_Param_GasPriceOracle }
    ;
}

public func set_globalAccountStore_onUpgrade(oldGlobals: GlobalsBeforeUpgrade) -> AccountStore {
    let oldGAS = oldGlobals.globalAccountStore;
    let acctsRemapResult = builtin_kvsForall(
        unsafecast<Kvs>(oldGAS.accounts),
        unsafecast<func(any, any, any) -> any>(acctRemapClosure),
        newmap<address, Account>,
    );
    return struct {
        accounts: unsafecast<map<address, Account>>(acctsRemapResult),
        retryBuffer: oldGAS.retryBuffer,
        numContracts: oldGAS.numContracts,
        codeRefTable: oldGAS.codeRefTable,
        escrowStore: oldGAS.escrowStore,
    };
}

func acctRemapClosure(_addr: address, oldAcct: before__accounts_Account, state: map<address, Account>) -> map<address, Account> {
    let acct = struct {
        addr: oldAcct.addr,
        blsKey: oldAcct.blsKey,
        nextSeqNum: oldAcct.nextSeqNum,
        ethBalance: oldAcct.ethBalance,
        contractInfo: oldAcct.contractInfo,
        aggregatorInfo: xif let Some(aggInfo) = oldAcct.aggregatorInfo {
            Some(
                struct {
                    decompressionState: aggInfo.decompressionState,
                    feeCollector: aggInfo.feeCollector,
                    baseTxFeeL1Gas: const::Default_Param_DefaultBaseTxFeeL1Gas,
                }
            )
        } else {
            None<AggregatorInfo>
        },
        aggregatorToPay: oldAcct.aggregatorToPay,
    };
    return state with {
        [acct.addr] = acct
    };
}

public func set_gasAccountingInfo_onUpgrade(input_globals: GlobalsBeforeUpgrade) -> GasAccountingInfo {
    let old = input_globals.gasAccountingInfo;
    return struct {
        txState: old.txState,
        feeConfig: struct {
            enabled: old.feeConfig.enabled,
            forNetwork: old.feeConfig.forNetwork,
            forCongestion: old.feeConfig.forCongestion,
            networkFeeRate: fixedPoint_new(
                old.feeConfig.baseFeeMultiplier.val,
                old.feeConfig.baseFeeMultiplier.shiftFactor - old.feeConfig.baseFeeMultiplier.val
            ),
        },
        currentPrices: struct {
            perL1CalldataUnit: old.currentPrices.perL1CalldataUnit,
            perStorageCell: old.currentPrices.perStorageCell,
            perArbGasBase: old.currentPrices.perArbGasBase,
            perArbGasCongestion: old.currentPrices.perArbGasCongestion,
            perArbGasTotal: old.currentPrices.perArbGasTotal,
        },
        gasRemainingThisBlock: old.gasRemainingThisBlock,
        congestionState: old.congestionState,
        speedLimitPerSecond: old.speedLimitPerSecond,
        pricingParams: struct {
            l1GasPerL1CalldataUnit: old.pricingParams.l1GasPerL1CalldataUnit,
            l1GasPerStorage: old.pricingParams.l1GasPerStorage,
            arbGasDivisor: old.pricingParams.arbGasDivisor,
        },
        gasAllocatedToThisBlock: old.gasAllocatedToThisBlock,
        retryablePrices: old.retryablePrices,
        allowedSenders: setOfAddresses_all(),
    };
}

public func set_codeSegGlobals_onUpgrade(
    _input_globals: GlobalsBeforeUpgrade
) -> struct {
    unreachableMask: uint,
    dummyAcceptContractCode: impure func(),
} {
    return struct {
        unreachableMask: 0,
        dummyAcceptContractCode: unsafecast<impure func()>(0),     // will initialize this properly later
    };
}

public func set_globalOutbox_onUpgrade(
    input_globals: GlobalsBeforeUpgrade
) -> struct {
    batch: MerkleTreeBuilder,
    batchNumber: uint,
    numInBatch: uint,
    evmTracer: EvmTracer,
} {
    return struct {
        batch: input_globals.globalOutbox.batch,
        batchNumber: input_globals.globalOutbox.batchNumber,
        numInBatch: input_globals.globalOutbox.numInBatch,
        evmTracer: evmTracer_new(),
    };
}
