//
// Copyright 2021, Offchain Labs, Inc. All rights reserved.
//

use bridge_arbos_versions::GlobalsBeforeUpgrade;

use bridge_arbos_versions::before__accounts_Account;
use bridge_arbos_versions::before__retrybuffer_RetryableTx;
use bridge_arbos_versions::before__messages_IncomingRequest;
use bridge_arbos_versions::before__messages_TxFeeStats;
use bridge_arbos_versions::before__inbox_ByteArray;

use accounts::Account;
use accounts::AccountStore;
use accounts::AggregatorInfo;

use evmCallStack::EvmCallFrame;
use evmCallStack::IncomingRequestAndLogs;

use inbox::TxRequestQueue;
use inbox::IncomingRequestQueueStack;

use messages::TxRequestData;

use retrybuffer::RetryableTx;

use std::addressSet::SetOfAddresses;
use std::addressSet::AddressPairSet;
use std::addressSet::setOfAddresses_emptySet;
use std::addressSet::setOfAddresses_add;
use std::addressSet::addressPairSet_new;

use std::queue::queue_map;

use core::kvs::Kvs;
use core::kvs::builtin_kvsDelete;
use core::kvs::builtin_kvsForall;

const constKeyForChainOwner = 0x1567aa7175e04611d194275bb504cc64e920959dd01df9d86ab047367aa4c534;


public func set_globalCallStack_onUpgrade(_oldGlobals: GlobalsBeforeUpgrade) -> option<EvmCallFrame> {
    return None<EvmCallFrame>;
}

public func set_globalCurrentTxRequest_onUpgrade(_oldGlobals: GlobalsBeforeUpgrade) -> TxRequestData {
    return unsafecast<TxRequestData>(());   // safe because globalCurrentTxRequest will be written before used
}

public func set_globalChainParameters_onUpgrade(oldGlobals: GlobalsBeforeUpgrade) -> map<uint, uint> {
    let params = oldGlobals.globalChainParameters;

    params = unsafecast<map<uint, uint> >(builtin_kvsDelete(
        unsafecast<Kvs>(params),
        const::constKeyForChainOwner,
    ));

    params = params with { [const::Atom_Param_EnableL1ContractAddressAliasing] = 0 };  // start with this disabled on upgrade

    return params;
}

public func set_globalAccountStore_onUpgrade(oldGlobals: GlobalsBeforeUpgrade) -> AccountStore {
    let oldGAS = oldGlobals.globalAccountStore;
    return struct {
        accounts: oldGAS.accounts,
        retryBuffer: struct {    // reformat retryables but don't rewrite their sender
            byTxId: {
                let m = newmap<uint, RetryableTx>;
                unsafecast<map<uint, RetryableTx> >(
                    builtin_kvsForall(
                        unsafecast<Kvs>(oldGAS.retryBuffer.byTxId),
                        unsafecast<func(any, any, any) -> any>(urbClosure),
                        m
                    )
                )
            },
            fifo: oldGAS.retryBuffer.fifo,
            txLifetimeSeconds: oldGAS.retryBuffer.txLifetimeSeconds,
        },
        numContracts: oldGAS.numContracts,
        codeRefTable: oldGAS.codeRefTable,
        escrowStore: oldGAS.escrowStore,
    };
}

func urbClosure(
    key: uint,
    value: before__retrybuffer_RetryableTx,
    state: map<uint, RetryableTx>
) -> map<uint, RetryableTx> {
    return state with {
        [key] = struct {
            txId: value.txId,
            sender: value.sender,
            destination: value.destination,
            callvalue: value.callvalue,
            callvalueEscrowKey: value.callvalueEscrowKey,
            beneficiary: value.beneficiary,
            calldata: value.calldata,
            expiryTime: value.expiryTime,
            l1Message: value.l1Message,
            originalSender: value.sender,
        }
    };
}

public func set_globalCurrentRetryableRequest_onUpgrade(
    _old: GlobalsBeforeUpgrade
) -> option<IncomingRequestAndLogs> {
    return None<IncomingRequestAndLogs>;
}

public func set_addressRemapExceptions_onUpgrade(_oldGlobals: GlobalsBeforeUpgrade) -> AddressPairSet {
    return addressPairSet_new();
}

public func set_globalInputQueue_onUpgrade(
    oldGlobals: GlobalsBeforeUpgrade
) -> struct {
    txQ: TxRequestQueue,
    batchQ: IncomingRequestQueueStack,
}{
    return struct {
        txQ: struct {
            q: queue_map(
                oldGlobals.globalInputQueue.txQ.q,
                unsafecast<func(any, any) -> any>(sgiqouClosure),
                (),
            ),
        },
        batchQ: oldGlobals.globalInputQueue.batchQ,
    };
}

func sgiqouClosure(
    item: struct {
        maxGas: uint,
        gasPrice: uint,
        seqNum: option<uint>,
        caller: address,
        calleeAddr: address,
        gasPayer: address,
        value: uint,
        calldata: before__inbox_ByteArray,
        nonMutating: bool,
        isConstructor: bool,
        incomingRequest: before__messages_IncomingRequest,
        feeStats: before__messages_TxFeeStats,
        fromRetryable: option<before__retrybuffer_RetryableTx>,
    },
    _unused: ()
) -> TxRequestData {
    return struct {
        maxGas: item.maxGas,
        gasPrice: item.gasPrice,
        seqNum: item.seqNum,
        caller: item.caller,
        calleeAddr: item.calleeAddr,
        gasPayer: item.gasPayer,
        value: item.value,
        calldata: item.calldata,
        nonMutating: item.nonMutating,
        isConstructor: item.isConstructor,
        incomingRequest: item.incomingRequest,
        feeStats: item.feeStats,
        fromRetryable: xif let Some(oldRetryable) = item.fromRetryable {
            Some(
                struct {
                    txId: oldRetryable.txId,
                    sender: oldRetryable.sender,
                    destination: oldRetryable.destination,
                    callvalue: oldRetryable.callvalue,
                    callvalueEscrowKey: oldRetryable.callvalueEscrowKey,
                    beneficiary: oldRetryable.beneficiary,
                    calldata: oldRetryable.calldata,
                    expiryTime: oldRetryable.expiryTime,
                    l1Message: oldRetryable.l1Message,
                    originalSender: oldRetryable.sender,
                }
            )
        } else {
            None<RetryableTx>
        },
        originalCaller: item.caller,
    };
}

public func set_chainOwners_onUpgrade(oldGlobals: GlobalsBeforeUpgrade) -> SetOfAddresses {
    // Change the chain owner from a chain parameter (a singleton address) to a set of addresses
    // For safety, include both the original and L1-contract-address-aliased version of the current owner as owners
    // This can't introduce new vulnerability because the alias can only be used by the old owner's L1 address.
    // We don't call the usual aliasing code here, because that code relies on globals that aren't initialized yet.

    let empty = setOfAddresses_emptySet();
    return xif let Some(oldOwner) = oldGlobals.globalChainParameters[const::constKeyForChainOwner] {
        setOfAddresses_add(
            setOfAddresses_add(
                empty,
                address(oldOwner),
            ),
            address(uint(oldOwner) + const::L1ToL2MapConstant),  // don't call standard function (it relies on not-yet-initialized data)
        )
    } else {
        empty
    };
}
