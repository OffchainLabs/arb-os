//
// Copyright 2021, Offchain Labs, Inc. All rights reserved.
//

use bridge_arbos_versions::GlobalsBeforeUpgrade;
use accounts::AccountStore;

use gasAccounting::TxGasState;
use gasAccounting::FeeConfig;
use gasAccounting::GasPrices;
use gasAccounting::CongestionState;
use gasAccounting::PricingParameters;
use gasAccounting::RetryablePrices;

use std::addressSet::SetOfAddresses;
use std::addressSet::setOfAddresses_all;

use evmCallStack::EvmCallFrame;
use messages::TxRequestData;


public func set_globalAccountStore_onUpgrade(input_globals: GlobalsBeforeUpgrade) -> AccountStore {
    return unsafecast<AccountStore>(input_globals.globalAccountStore);
}

public func set_evmOpJumpTable_onUpgrade(input_globals: GlobalsBeforeUpgrade) -> [48]impure func() {
    return unsafecast<[48]impure func()>(input_globals.evmOpJumpTable);
}

public func set_globalCallStack_onUpgrade(_input_globals: GlobalsBeforeUpgrade) -> option<EvmCallFrame> {
    return None<EvmCallFrame>;
}

public func set_gasAccountingInfo_onUpgrade(input_globals: GlobalsBeforeUpgrade) -> GasAccountingInfo {
    let old = input_globals.gasAccountingInfo;
    let l1GasPrice = input_globals.globalL1GasPriceEstimator.estimateWei;
    return struct {
        txState: old.txState,
        feeConfig: old.feeConfig,
        currentPrices: struct {
            perL1CalldataUnit: old.pricingParams.l1GasPerL2Tx * l1GasPrice,
            perStorageCell: old.pricingParams.l1GasPerStorage * l1GasPrice,
            perArbGasBase: l1GasPrice / old.pricingParams.arbGasDivisor,
            perArbGasCongestion: old.congestionState.congestionPriceWei,
            perArbGasTotal: (l1GasPrice / old.pricingParams.arbGasDivisor) + old.congestionState.congestionPriceWei,
        },
        gasRemainingThisBlock: old.gasRemainingThisBlock,
        congestionState: old.congestionState,
        speedLimitPerSecond: old.speedLimitPerSecond,
        pricingParams: struct {
            l1GasPerL1CalldataUnit: old.pricingParams.l1GasPerL1CalldataUnit,
            l1GasPerStorage: old.pricingParams.l1GasPerStorage,
            arbGasDivisor: old.pricingParams.arbGasDivisor,
        },
        gasAllocatedToThisBlock: old.gasAllocatedToThisBlock,
        retryablePrices: old.retryablePrices,
    };
}

public func set_codeSegGlobals_onUpgrade(
    input_globals: GlobalsBeforeUpgrade
) -> struct {
    unreachableMask: uint,
    dummyAcceptContractCode: impure func(),
} {
    return struct {
        unreachableMask: 0,
        dummyAcceptContractCode: unsafecast<impure func()>(0),     // will initialize this properly later
    };
}

public func set_gasAccountingInfo_onUpgrade(
    input_globals: GlobalsBeforeUpgrade
) -> struct {
    txState: option<TxGasState>,       // status of currently active tx (if there is one)
    feeConfig: FeeConfig,              // fee configuration
    currentPrices: GasPrices,          // current prices for resources
    gasRemainingThisBlock: uint,       // amount of gas remaining for this Arbitrum block
    congestionState: CongestionState,  // state of congestion pricing algorithm
    speedLimitPerSecond: uint,         // nominal ArbGas available for computation per second
    pricingParams: PricingParameters,  // parameters that affect pricing
    gasAllocatedToThisBlock: uint,     // total amount of gas allocated to the current Arbitrum block
    retryablePrices: RetryablePrices,  // prices of retryable txs
    allowedSenders: SetOfAddresses,    // who is allowed to send txs
} {
    return struct {
        txState: input_globals.gasAccountingInfo.txState,
        feeConfig: input_globals.gasAccountingInfo.feeConfig,
        currentPrices: input_globals.gasAccountingInfo.currentPrices,
        gasRemainingThisBlock: input_globals.gasAccountingInfo.gasRemainingThisBlock,
        congestionState: input_globals.gasAccountingInfo.congestionState,
        speedLimitPerSecond: input_globals.gasAccountingInfo.speedLimitPerSecond,
        pricingParams: input_globals.gasAccountingInfo.pricingParams,
        gasAllocatedToThisBlock: input_globals.gasAccountingInfo.gasAllocatedToThisBlock,
        retryablePrices: input_globals.gasAccountingInfo.retryablePrices,
        allowedSenders: setOfAddresses_all(),
    };
}

public func set_globalCallStack_onUpgrade(_input_globals: GlobalsBeforeUpgrade) -> option<EvmCallFrame> {
    return None<EvmCallFrame>;
}

public func set_globalCurrentTxRequest_onUpgrade(input_globals: GlobalsBeforeUpgrade) -> TxRequestData {
    return unsafecast<TxRequestData>(input_globals.globalCurrentTxRequest);
}

public func set___fixedLocationGlobal_onUpgrade(_input_globals: GlobalsBeforeUpgrade) -> impure func(uint) {
    return unsafecast<impure func(uint)>(0);
}

public func set_globalChainParameters_onUpgrade(_input_globals: GlobalsBeforeUpgrade) -> map<uint, uint> {
    return newmap<uint, uint>;
}