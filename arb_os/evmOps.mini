//
// Copyright 2020, Offchain Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import type Account;
import type EvmCallFrame;
import type EvmLogs;
import type ByteArray;
import type ByteStream;
import type MarshalledBytes;

import impure func errorHandler();

import impure func evmCallStack_topFrame() -> option<EvmCallFrame>;
import impure func evmCallStack_oldestCallFrame() -> option<EvmCallFrame>;
import impure func evmCallStack_setAccount(addr: address, acct: Account) -> bool;
import impure func evmCallStack_getAccount(addr: address) -> option<Account>;
import impure func evmCallStack_getTopFrameReturnData() -> option<ByteArray>;
import impure func evmCallStack_getTopFrameMemoryOrDie() -> ByteArray;
import impure func evmCallStack_setTopFrameMemory(mem: ByteArray) -> bool;
import impure func evmCallStack_setTopFrameStorageCell(offset: uint, val: uint) -> option<()>;
import impure func evmCallStack_addEvmLogToCurrent(log: any) -> option<()>;
import impure func evmCallStack_selfDestructCurrentAccount(owner: address);
import impure func evmCallStack_doCall(
    kind: uint,
    gas: uint,
    calleeAddr: address,
    balance: uint,
    argsOffset: uint,
    argsLength: uint,
    retOffset: uint,
    retLength: uint,
    resumeCodePoint: func(),
) -> option<()>;
import impure func evmCallStack_returnFromCall(
    success: bool,
    returnOffset: uint,
    returnLength: uint
) -> option<()>;

import func evmCallFrame_runningAsAccount(frame: EvmCallFrame) -> Account;
import func evmCallFrame_runningCodeFromAccount(frame: EvmCallFrame) -> Account;
import func evmCallFrame_getAccount(frame: EvmCallFrame, addr: address) -> Account;
import func evmCallFrame_getCaller(frame: EvmCallFrame) -> address;
import func evmCallFrame_getMemory(frame: EvmCallFrame) -> ByteArray;
import func evmCallFrame_getResumeCodePoint(frame: EvmCallFrame) -> option<func()>;
import func evmCallFrame_getCallvalue(frame: EvmCallFrame) -> uint;
import func evmCallFrame_getCalldata(frame: EvmCallFrame) -> ByteArray;
import func evmCallFrame_getEvmLogs(frame: EvmCallFrame) -> EvmLogs;

import func account_getAddress(acct: Account) -> address;
import func account_getCodeSize(acct: Account) -> uint;
import func account_getBalance(acct: Account) -> uint;
import func account_getCode(acct: Account) -> option<ByteArray>;
import func account_getStorageCell(acct: Account, offset: uint) -> option<uint>;
import func account_getAllStorage(account: Account) -> option<map<uint, uint>>;
import func account_getEvmJumpTable(acct: Account) -> option<map<uint, impure func()>>;
import func account_fetchAndIncrSeqNum(account: Account) -> (uint, Account);
import func account_setContractInfo(
    acct: Account,
    code: ByteArray,
    evmJumpTable: map<uint, impure func()>,
    startCodePoint: impure func(),
    storage: map<uint, uint>
) -> Account;
import func account_isEmpty(acct: Account) -> bool;
import func pristineAccount(addr: address) -> Account;

import impure func inbox_currentTimestamp() -> uint;
import impure func inbox_currentBlockNumber() -> uint;

import func evmlogs_empty() -> EvmLogs;

import func bytearray_new(capacity: uint) -> ByteArray;
import func bytearray_size(ba: ByteArray) -> uint;
import func bytearray_getByte(ba: ByteArray, offset: uint) -> uint;
import func bytearray_setByte(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_get256(ba: ByteArray, offset: uint) -> uint;
import func bytearray_set256(ba: ByteArray, offset: uint, val: uint) -> ByteArray;
import func bytearray_extract(ba: ByteArray, offset: uint, nbytes: uint) -> ByteArray;
import func bytearray_copy(from: ByteArray, fromOffset: uint, to: ByteArray, toOffset: uint, nbytes: uint) -> ByteArray;
import func bytearray_marshalFull(from: ByteArray) -> MarshalledBytes;
import func bytestream_new(from: ByteArray) -> ByteStream;

import impure func translateEvmCodeSegment(bs: ByteStream) -> option<(impure func(), map<uint, impure func()>)>;

import func keccak256(array: ByteArray, offset: uint, nbytes: uint) -> bytes32;
import func keccakOfRlpEncodedAddrUintPair(addr: address, ui: uint) -> bytes32;


// Any function with a name like evmOp_XXX is designed to implement the XXX instruction in EVM.
// Compiled EVM code will call that function to implement the XXX instruction.
// Most of the functions are fairly simple, and access the callframe or similar information.


public impure func evmOp_stop() {
    // return from the current call, with no calldata
    evmOp_return(0, 0);
}

public impure func evmOp_sha3(baseMemAddr: uint, nbytes: uint) -> bytes32 {
    return keccak256(evmCallStack_getTopFrameMemoryOrDie(), baseMemAddr, nbytes);
}

public impure func evmOp_address() -> address {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return account_getAddress(evmCallFrame_runningAsAccount(topFrame));
    }

    evm_runtimePanic();
    return address(0);
}

public impure func evmOp_balance(addr: address) -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return account_getBalance(
            evmCallFrame_getAccount(topFrame, addr)
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public impure func evmOp_selfbalance() -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return account_getBalance(
            evmCallFrame_runningAsAccount(topFrame)
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}
    
public impure func evmOp_origin() -> address {
    if let Some(oldie) = evmCallStack_oldestCallFrame() {
        return account_getAddress(evmCallFrame_runningAsAccount(oldie));
    }

    evm_runtimePanic();
    return address(0);
}
    
public impure func evmOp_caller() -> address {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return evmCallFrame_getCaller(topFrame);
    }

    evm_runtimePanic();
    return address(0);
}

public impure func evmOp_callvalue() -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return evmCallFrame_getCallvalue(topFrame);
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public impure func evmOp_calldataload(offset: uint) -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return bytearray_get256(evmCallFrame_getCalldata(topFrame), offset);
    }

    evm_runtimePanic();
    return 0;
}

public impure func evmOp_calldatasize() -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return bytearray_size(evmCallFrame_getCalldata(topFrame));
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public impure func evmOp_calldatacopy(memAddr: uint, calldataOffset: uint, nbytes: uint) {
    if let Some(topFrame) = evmCallStack_topFrame() {
        let newMemory = bytearray_copy(
            evmCallFrame_getCalldata(topFrame),
            calldataOffset,
            evmCallFrame_getMemory(topFrame),
            memAddr,
            nbytes
        );
        if (evmCallStack_setTopFrameMemory(newMemory,)) {
            return;
        }
    }

    evm_runtimePanic();
}

public impure func evmOp_codesize() -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return account_getCodeSize(
            evmCallFrame_runningCodeFromAccount(topFrame)
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public impure func evmOp_codecopy(memAddr: uint, codeOffset: uint, nbytes: uint) {
    if let Some(topFrame) = evmCallStack_topFrame() {
        let memory = evmCallFrame_getMemory(topFrame);
        if let Some(code) = account_getCode(
            evmCallFrame_runningCodeFromAccount(topFrame)
        ) {
            let updatedMemory = bytearray_copy(
                code,
                codeOffset,
                memory,
                memAddr,
                nbytes
            );
            if (evmCallStack_setTopFrameMemory(updatedMemory,)) {
                return;
            }
        }
    }

    evm_runtimePanic();
}

public impure func evmOp_extcodesize(addr: address) -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return account_getCodeSize(
            evmCallFrame_getAccount(topFrame, addr)
        );
    }

    evm_runtimePanic();
    return 0;
}

public impure func evmOp_extcodecopy(addr: address, memAddr: uint, codeOffset: uint, nbytes: uint) {
    if let Some(topFrame) = evmCallStack_topFrame() {
        let memory = evmCallFrame_getMemory(topFrame);
        if let Some(code) = account_getCode(
            evmCallFrame_getAccount(topFrame, addr)
        ) {
            let updatedMemory = bytearray_copy(
                code,
                codeOffset,
                memory,
                memAddr,
                nbytes
            );
            if (evmCallStack_setTopFrameMemory(updatedMemory,)) {
                return;
            }
        }
    }

    evm_runtimePanic();
}

public impure func evmOp_returndatasize() -> uint {
    if let Some(returnData) = evmCallStack_getTopFrameReturnData() {
        return bytearray_size(returnData);
    }

    evm_runtimePanic();
    return 0;
}

public impure func evmOp_returndatacopy(memAddr: uint, dataOffset: uint, nbytes: uint) {
    if let Some(returnData) = evmCallStack_getTopFrameReturnData() {
        let memory = evmCallStack_getTopFrameMemoryOrDie();
        let updatedMemory = bytearray_copy(
            returnData,
            0,
            memory,
            dataOffset,
            nbytes
        );
        if (evmCallStack_setTopFrameMemory(updatedMemory,)) {
           return;
        }
    }

    evm_runtimePanic();
}

public impure func evmOp_timestamp() -> uint {
    return inbox_currentTimestamp();
}

public impure func evmOp_number() -> uint {
    return inbox_currentBlockNumber();
}

public impure func evmOp_mload(memAddr: uint) -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return bytearray_get256(
            evmCallFrame_getMemory(topFrame),
            memAddr
        );
    }

    evm_runtimePanic();
    return 0;
}

public impure func evmOp_mstore(memAddr: uint, value: uint) {
    if let Some(topFrame) = evmCallStack_topFrame() {
        let memory = bytearray_set256(
            evmCallFrame_getMemory(topFrame),
            memAddr,
            value
        );
        if (evmCallStack_setTopFrameMemory(memory)) {
            return;
        }
    }

    evm_runtimePanic();
}

public impure func evmOp_mstore8(memAddr: uint, value:uint) {
    if let Some(topFrame) = evmCallStack_topFrame() {
        let memory = bytearray_setByte(
            evmCallFrame_getMemory(topFrame),
            memAddr,
            value
        );
        if (evmCallStack_setTopFrameMemory(memory)) {
            return;
        }
    }

    evm_runtimePanic();
}
    
public impure func evmOp_sload(storageAddr: uint) -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        if let Some(val) = account_getStorageCell(
            evmCallFrame_runningAsAccount(topFrame),
            storageAddr
        ) {
            return val;
        }
    }

    evm_runtimePanic();
    return 0;
}

public impure func evmOp_sstore(storageAddr: uint, value: uint) {
    if let Some(topFrame) = evmCallStack_topFrame() {
        if let Some(_) = evmCallStack_setTopFrameStorageCell(
            storageAddr,
            value
        ) {
            return;
        }
    }

    evm_runtimePanic();
}
    
public impure func evmOp_getjumpaddr(evm_pc: uint) -> impure func() {
    // This one isn't actually an EVM instruction.
    // It's a "pseudo-instruction" that translates an EVM jump destination to an AVM codepoint in the compiled code.
    if let Some(topFrame) = evmCallStack_topFrame() {
        if let Some(jumpTable) = account_getEvmJumpTable(
            evmCallFrame_runningCodeFromAccount(topFrame)
        ) {
            if let Some(codept) = jumpTable[evm_pc] {
                return codept;
            } else {
                evm_error();   // EVM code tried to jump to a forbidden EVM jump destination
                panic;
            }
        }
    }

    evm_runtimePanic();
    panic;
}

public impure func evmOp_msize() -> uint {
    if let Some(topFrame) = evmCallStack_topFrame() {
        return bytearray_size(
            evmCallFrame_getMemory(topFrame)
        );
    } else {
        evm_runtimePanic();
        return 0;
    }
}

public impure func evmOp_log0(
    memAddr: uint, 
    nbytes: uint
) {
    let data = bytearray_extract(
        evmCallStack_getTopFrameMemoryOrDie(),
        memAddr,
        nbytes
    );
    if (evmCallStack_addEvmLogToCurrent(
        (
            address(0),  // addEvmLogToCurrent will fill this in
            bytearray_marshalFull(data),
        )
    ) == Some(()) ) {
        return;
    }

    evm_runtimePanic();
    panic;
}

public impure func evmOp_log1(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint
) {
    let data = bytearray_extract(
        evmCallStack_getTopFrameMemoryOrDie(),
        memAddr,
        nbytes
    );
    if (evmCallStack_addEvmLogToCurrent(
        (
            address(0),  // addEvmLogToCurrent will fill this in
            bytearray_marshalFull(data),
            topic0
        )
    ) == Some(()) ) {
        return;
    }

    evm_runtimePanic();
    panic;
}

public impure func evmOp_log2(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint,
    topic1: uint,
) {
    let data = bytearray_extract(
        evmCallStack_getTopFrameMemoryOrDie(),
        memAddr,
        nbytes
    );
    if (evmCallStack_addEvmLogToCurrent(
        (
            address(0),  // addEvmLogToCurrent will fill this in
            bytearray_marshalFull(data),
            topic0,
            topic1
        )
    ) == Some(()) ) {
        return;
    }

    evm_runtimePanic();
    panic;
}

public impure func evmOp_log3(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint,
    topic1: uint,
    topic2: uint,
) {
    let data = bytearray_extract(
        evmCallStack_getTopFrameMemoryOrDie(),
        memAddr,
        nbytes
    );
    if (evmCallStack_addEvmLogToCurrent(
        (
            address(0),  // addEvmLogToCurrent will fill this in
            bytearray_marshalFull(data),
            topic0,
            topic1,
            topic2
        )
    ) == Some(()) ) {
        return;
    }

    evm_runtimePanic();
    panic;
}

public impure func evmOp_log4(
    memAddr: uint, 
    nbytes: uint, 
    topic0: uint,
    topic1: uint,
    topic2: uint,
    topic3: uint,
) {
    let data = bytearray_extract(
        evmCallStack_getTopFrameMemoryOrDie(),
        memAddr,
        nbytes
    );
    if (evmCallStack_addEvmLogToCurrent(
        (
            address(0),  // addEvmLogToCurrent will fill this in
            bytearray_marshalFull(data),
            topic0,
            topic1,
            topic2,
            topic3
        )
    ) == Some(()) ) {
        return;
    }

    evm_runtimePanic();
    panic;
}

public func evmOp_sloadbytes() {
    // believe this is a non-standard opcode
    evm_notYetImplemented(14,);
}

public func evmOp_sstorebytes() {
    // believe this is a non-standard opcode
    evm_notYetImplemented(15,);
}

public func evmOp_ssize() {
    // believe this is a non-standard opcode
    evm_notYetImplemented(16,);
}

public impure func evmOp_call(
    gas: uint,
    callee: address,
    balance: uint,
    argsOffset: uint,
    argsLength: uint,
    retOffset: uint,
    retLength: uint
) -> bool {
    // First, get the return address of our caller.
    // This will be the second-from-top item on the AVM AuxStack.
    // Get a copy of it, without disturbing anything.
    let resumeCodePoint = asm() func() {
        auxpop
        auxpop
        dup0
        swap2
        swap1
        auxpush
        auxpush
    };

    // Now make the call.
    // After the call completes, control will be thrown directly back to resumeCodePoint.
    let res = evmCallStack_doCall(
        0,
        gas,
        callee,
        balance,
        argsOffset,
        argsLength,
        retOffset,
        retLength,
        resumeCodePoint
    );
    if (res == None<()>) {
        return false;  // couldn't make a call, return failure
    } else {
        // should never get here -- control should have been thrown elsewhere
        panic;
    }
}

public impure func evmOp_callcode(
    gas: uint,
    callee: address,
    balance: uint,
    argsOffset: uint,
    argsLength: uint,
    retOffset: uint,
    retLength: uint
) -> bool {
    // This is the same as evmOp_call, except for the callKind.
    let resumeCodePoint = asm() func() {
        auxpop
        auxpop
        dup0
        swap2
        swap1
        auxpush
        auxpush
    };
    let res = evmCallStack_doCall(
        1,
        gas,
        callee,
        balance,
        argsOffset,
        argsLength,
        retOffset,
        retLength,
        resumeCodePoint
    );
    if (res == None<()>) {
        return false;  // couldn't make a call, return failure
    } else {
        // should never get here -- control should have been thrown elsewhere
        panic;
    }
}

public impure func evmOp_delegatecall(
    gas: uint,
    callee: address,
    argsOffset: uint,
    argsLength: uint,
    retOffset: uint,
    retLength: uint
) -> bool {
    // This is the same as evmOp_call, except for the callKind.
     let resumeCodePoint = asm() func() {
         auxpop
         auxpop
         dup0
         swap2
         swap1
         auxpush
         auxpush
     };
     let res = evmCallStack_doCall(
         2,
         gas,
         callee,
         0,  // balance is zero for a delegatecall
         argsOffset,
         argsLength,
         retOffset,
         retLength,
         resumeCodePoint
     );
     if (res == None<()>) {
         return false;  // couldn't make a call, return failure
     } else {
         // should never get here -- control should have been thrown elsewhere
         panic;
     }}

public impure func evmOp_staticcall(
    gas: uint,
    callee: address,
    argsOffset: uint,
    argsLength: uint,
    retOffset: uint,
    retLength: uint
) -> bool {
    // This is the same as evmOp_call, except for the callKind.
    let resumeCodePoint = asm() func() {
        auxpop
        auxpop
        dup0
        swap2
        swap1
        auxpush
        auxpush
    };
    let res = evmCallStack_doCall(
        3,
        gas,
        callee,
        0,  // balance is zero for a staticcall
        argsOffset,
        argsLength,
        retOffset,
        retLength,
        resumeCodePoint
    );
    if (res == None<()>) {
        return false;  // couldn't make a call, return failure
    } else {
        // should never get here -- control should have been thrown elsewhere
        panic;
    }
}

public impure func evmOp_revert(memOffset: uint, memNbytes: uint) {
    let _ = evmCallStack_returnFromCall(false, memOffset, memNbytes);

    evm_runtimePanic();
}

public impure func evmOp_return(memOffset: uint, memNbytes: uint) {
    let _ = evmCallStack_returnFromCall(true, memOffset, memNbytes);

    evm_runtimePanic();
}

public func evmOp_txexecgas() {
    // believe this is a non-standard opcode
    evm_notYetImplemented(23,);
}

public impure func evmOp_selfdestruct(owner: address) {
    evmCallStack_selfDestructCurrentAccount(owner,);
}

public impure func evmOp_create(value: uint, offset: uint, length: uint) -> address {
    if let Some(topFrame) = evmCallStack_topFrame() {
        let myAcct = evmCallFrame_runningAsAccount(topFrame);
        let myAddr = account_getAddress(myAcct);
        let (seqNum, updatedAcct) = account_fetchAndIncrSeqNum(myAcct);
        if ( ! evmCallStack_setAccount(myAddr, updatedAcct)) {
            return address(0);
        }
        let newAddress = address(keccakOfRlpEncodedAddrUintPair(myAddr, seqNum));
        return doCreationOpcode(value, offset, length, newAddress);
    }

    evm_runtimePanic();
    panic;
}

public impure func evmOp_create2(value: uint, offset: uint, length: uint, salt: uint) -> address {
    if let Some(topFrame) = evmCallStack_topFrame() {
        let myAcct = evmCallFrame_runningAsAccount(topFrame);
        let myAddr = account_getAddress(myAcct);
        let newAddrBuf = bytearray_new(85);
        newAddrBuf = bytearray_setByte(newAddrBuf, 0, 0xff);
        newAddrBuf = bytearray_set256(newAddrBuf, 1, 2048*uint(myAddr));
        newAddrBuf = bytearray_set256(newAddrBuf, 21, salt);
        newAddrBuf = bytearray_set256(
            newAddrBuf,
            53,
            uint(keccak256(
                evmCallFrame_getMemory(topFrame),
                offset,
                length
            ))
        );
        let newAddress = address(keccak256(newAddrBuf, 0, 85));
        return doCreationOpcode(value, offset, length, newAddress);
    }

    evm_runtimePanic();
    panic;
}

impure func doCreationOpcode(value: uint, offset: uint, length: uint, newAddress: address) -> address {
    // make sure there isn't already an account at the given address
    if let Some(acct) = evmCallStack_getAccount(newAddress) {
        if ( ! account_isEmpty(acct)) {
            // there is already an account at that address; return failure
            return address(0);
        }
    } else {
        // somehow there isn't an EVM callframe
        evm_runtimePanic();
        panic;
    }

    let constructorCode = bytearray_extract(
        evmCallStack_getTopFrameMemoryOrDie(),
        offset,
        length
    );
    if let Some(res) = translateEvmCodeSegment(bytestream_new(constructorCode)) {
        let (startPoint, evmJumpTable) = res;

        // Create a new account to run the constructor code.
        if (evmCallStack_setAccount(
                newAddress,
                account_setContractInfo(
                    pristineAccount(newAddress),
                    constructorCode,
                    evmJumpTable,
                    startPoint,
                    newmap<uint, uint>
                )
            )
        ) {
            // Now for the slightly tricky part.
            // We're going to call the untrusted constructor, which might end up trashing our
            //    Mini-language callstack (which is stored on the AVM auxstack).
            // The possibly-trashed callstack includes our local variables and the return address of our caller.
            // It also contains the locals and return address of our caller, which we also need to preserve.
            // We don't need to preserve any more because our caller's caller is translated EVM code,
            //    which doesn't use the aux stack and isn't trusted to maintain any invariants about it.
            // We will make a copy of the things we want to preserve, on the AVM stack, because the AVM stack
            //    gets saved and restored across calls to untrusted code.
            // After the return we'll restore the saved info, and continue.

            // save top four AVM auxstack items onto the AVM stack (locals and return address of us and our caller)
            asm(((),(),(),()),) {
                auxpop
                swap1
                auxpop
                swap1
                auxpop
                swap1
                auxpop
                swap1
                dup1
                auxpush
                [0] tset
                dup1
                auxpush
                [1] tset
                dup1
                auxpush
                [2] tset
                dup1
                auxpush
                [3] tset
            };

            let constructorSucceeded = false;

            // We can't save the result of this call to a local variable, because we can't (yet) trust
            //     that our local callframe is in a reasonable state. So we have to put it in an if.
            if (evmOp_call(
                1000000000,  // gas allocation
                newAddress,
                value,
                0,           // no calldata passed to constructor
                0,
                0,           // don't copy returndata back into caller's memory
                0,
            )) {
                // Constructor call succeeded.
                // Recover our saved information from the stack, put it back onto the auxstack
                asm() {
                    dup0
                    [0] tget
                    auxpush
                    dup0
                    [1] tget
                    auxpush
                    dup0
                    [2] tget
                    auxpush
                    [3] tget
                    auxpush
                };

                constructorSucceeded = true;
            } else {
                // Recover our saved information from the stack, put it back onto the auxstack
                asm() {
                    dup0
                    [0] tget
                    auxpush
                    dup0
                    [1] tget
                    auxpush
                    dup0
                    [2] tget
                    auxpush
                    [3] tget
                    auxpush
                 };
            }

            if (constructorSucceeded) {
                if let Some(contractCode) = evmCallStack_getTopFrameReturnData() {
                    if let Some(res) = translateEvmCodeSegment(bytestream_new(contractCode)) {
                        let (startPoint2, evmJumpTable2) = res;
                        if let Some(oldAcct) = evmCallStack_getAccount(newAddress) {
                            let storage = newmap<uint, uint>;
                            if let Some(st) = account_getAllStorage(oldAcct) {
                                storage = st;
                            }
                            if (evmCallStack_setAccount(
                                    newAddress,
                                    account_setContractInfo(
                                        oldAcct,
                                        contractCode,
                                        evmJumpTable2,
                                        startPoint2,
                                        storage
                                    )
                                )
                            ) {
                                return newAddress;
                            }
                        }
                    }
                }
            }
        }
    }

    // clean up the state and return failure
    let _ = evmCallStack_setAccount(newAddress, pristineAccount(newAddress));
    return address(0);
}

impure func evm_error() {
    // This should be called when EVM code has generated an EVM error.
    evmOp_revert(0, 0);  // should never return

}

func evm_runtimePanic() {
    // This should be called when something that "shouldn't ever happen" has occurred.
    // It should only be called if something has gone wrong in the trusted code.
    // If untrusted code has encountered an error, that will be handled elsewhere.
    errorHandler();
}

func evm_notYetImplemented(op: uint) {
    panic;
}
