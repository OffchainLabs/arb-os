//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

import type IncomingRequest;
import type AccountStore;
import type Account;
import type EvmLogs;
import type Queue;
import type ByteArray;
import type ByteStream;
import type MarshalledBytes;
import type Stack;
import type StorageMap;

import impure func errorHandler();

import impure func getGlobalAccountStore() -> AccountStore;
import impure func setGlobalAccountStore(acctStore: AccountStore);
import func accountStore_get(store: AccountStore, addr: address) -> Account;
import func accountStore_set(store: AccountStore, addr: address, acct: Account) -> AccountStore;
import func accountStore_transferEthBalance(
    acctStore: AccountStore,
    from: address,
    to: address,
    amount: uint
) -> option<AccountStore>;
import func accountStore_destroyAndTransferBalance(
    acctStore: AccountStore,
    victim: address,
    recipient: address
) -> AccountStore;
import func accountStore_cloneContract(
    acctStore: AccountStore,
    oldAddr: address,
    newAddr: address
) -> option<AccountStore>;
import func account_setStorageCell(acct: Account, offset: uint, value: uint) -> option<Account>;
import func account_getBalance(acct: Account) -> uint;
import func account_setBalance(acct: Account, bal: uint) -> Account;
import func account_deductFromEthBalance(account: Account, deduction: uint) -> option<Account>;
import func account_getAllStorage(account: Account) -> option<StorageMap>;
import func account_getStartCodePoint(account: Account) -> option<impure func()>;
import func account_setContractInfo(
    acct: Account,
    code: ByteArray,
    evmJumpTable: map<uint, impure func()>,
    startCodePoint: impure func(),
    storage: StorageMap
) -> Account;
import func account_fetchAndIncrSeqNum(account: Account) -> (uint, Account);
import func account_incrSeqNum(account: Account) -> Account;
import func pristineAccount(addr: address) -> Account;

import func evmlogs_empty() -> EvmLogs;
import func evmlogs_appendAny(logs: EvmLogs, item: any) -> EvmLogs;

import func bytearray_new(capacity: uint) -> ByteArray;
import func bytearray_marshalFull(ba: ByteArray) -> MarshalledBytes;
import func bytearray_extract(ba: ByteArray, offset: uint, nbytes: uint) -> ByteArray;
import func bytearray_copy(
    from: ByteArray,   fromOffset: uint,
    to: ByteArray,     toOffset: uint,
    nbytes: uint
) -> ByteArray;
import func bytearray_setByte(ba: ByteArray, offset: uint, value: uint) -> ByteArray;
import func bytearray_set256(ba: ByteArray, offset: uint, value: uint) -> ByteArray;
import func bytestream_new(ba: ByteArray) -> ByteStream;

import func storageMap_new() -> StorageMap;

import func queue_new() -> Queue;
import func queue_isEmpty(q: Queue) -> bool;
import func queue_get(q: Queue) -> option<(Queue, any)>;
import func queue_put(q: Queue, val: any) -> Queue;

import func stack_new() -> Stack;
import func stack_isEmpty(stack: Stack) -> bool;
import func stack_push(stack: Stack, value: any) -> Stack;
import func stack_pop(stack: Stack) -> option<(Stack, any)>;

import impure func gasAccounting_startTxCharges(maxGas: uint, gasPrice: uint, payer: address) -> option<()>;
import impure func gasAccounting_endTxCharges() -> option<GasUsage>;
import impure func gasAccounting_pauseTxCharges() -> uint;
import impure func gasAccounting_resumeTxCharges(allocation: uint) -> uint;

import impure func translateEvmCodeSegment(
    bs: ByteStream
) -> option<(impure func(), map<uint, impure func()>)>;

import impure func emitLog(
    l1message: IncomingRequest,
    resultCode: uint,
    maybeReturnData: option<ByteArray>,
    maybeEvmLogs: option<EvmLogs>,
    gasUsage: option<GasUsage>,
);

import impure func mainRunLoop();

import impure func sendMessage(msgType: uint, sender: address, data: ByteArray);
import impure func sendQueuedMessages(queue: Queue);


// This is declared identically in gasAccounting.mini
type GasUsage = struct {
    gasUsed: uint,
    gasPriceWei: uint,
}

// This callframe is used to represent an EVM call in progress.
// The callframe will have a full copy of the system state, but
//        that state will be contingent on the call succeeding.
// If the call succeeds, we'll copy the call's state into the caller as the new
//        state, but if the call fails we'll discard the state from the callframe.
// (For staticcalls, we will discard state even if the call succeeds, as the EVM spec requires.)
type EvmCallFrame = struct {
    runningAs: address,                 // call is running in the execution/security context of this address
    runningCodeFrom: address,           // call is running code associated with this address
    accountStore: AccountStore,         // accountStore used for executing this call
    runningAsAccount: Account,          // cache of accountStore[runningAs]
    caller: address,                    // who called this
    callKind: uint,                     // type of call: 0=call, 2=delegatecall, 3=staticcall, 4=constructor
    calldata: ByteArray,                // calldata passed in by our caller
    callvalue: uint,                    // Eth value given to this call by its caller
    returnInfo: option<ReturnInfo>,     // result of last subcall made by this call (if any)
    memory: ByteArray,                  // EVM memory of this call
    evmLogs: EvmLogs,                   // EVM logs created by this call and its subcalls
    selfDestructQueue: Queue,           // set of self-destruct directives created by this call and its subcalls
    resumeInfo: option<ResumeInfo>,     // if call is suspended, its state will be saved here
    sendQueue: Queue,                   // queue of messages to be sent if the transaction succeeds
    parent: option<any>,                // call-frame that created this one, or None if this is user call
                      // parent is really an option<EvmCallFrame>, but compiler doesn't allow recursive types
}

type ReturnInfo = struct {  // information about a call that previously completed
    data: ByteArray,
    status: bool,
}

type ResumeInfo = struct {  // information used to resume a call after a subcall returns
    codePoint: func(),      // where to resume execution
    stackContents: Stack,   // saved contents of stack
    returnDataOffset: uint, // where returndata from subcall should be put
    returnDataNbytes: uint, // max amount of returndata that subcall can provide
    callType: uint,         // call type of the subcall
    savedGas: uint,         // how much of the caller's gas was not lent to the subcall
}

var globalCallStack: option<EvmCallFrame>;   // call frame of currently running call, if any
var globalCurrentIncomingRequest: IncomingRequest;  // request that launched the top-level call

// This struct is declared identically in inbox.mini and elsewhere
type IncomingRequest = struct {
    kind: uint,               // type of message
    blockNumber: uint,        // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    inboxSeqNum: uint,        // sequence number in L1 inbox
    msgData: MarshalledBytes  // contents of the message, as a marshalled bytearray
}

public impure func evmCallStack_init() {
    globalCallStack = None<EvmCallFrame>;
}


type TxRequestData = struct {
    maxGas: uint,
    gasPrice: uint,
    seqNum: option<uint>,
    caller: address,
    calleeAddr: address,
    value: uint,
    calldata: ByteArray,
    incomingRequest: IncomingRequest,
}

public impure func initEvmCallStack(
    callKind: uint,
    request: TxRequestData,
) {
    // Set up the call frame for a top-level call, and launch the call's execution.
    if let Some(entryPoint) = account_getStartCodePoint(
        accountStore_get(
            getGlobalAccountStore(),
            request.calleeAddr
        )
    ) {
        if (gasAccounting_startTxCharges(request.maxGas, request.gasPrice, request.caller) != None<()>) {
            // increment the caller's sequence number, if caller has sufficient balance
            let acctStore = getGlobalAccountStore();
            if (account_getBalance(accountStore_get(acctStore, request.caller)) >= request.value) {
                setGlobalAccountStore(
                    accountStore_set(
                        acctStore,
                        request.caller,
                        account_incrSeqNum(
                            accountStore_get(acctStore, request.caller)
                        )
                    )
                );
            }

            globalCurrentIncomingRequest = request.incomingRequest;

            // pay callvalue from caller to the called contract
            // payment will only be recorded inside the callframe, so it will be discarded if the call reverts
            if let Some(globalAS) = accountStore_transferEthBalance(
                getGlobalAccountStore(),
                request.caller,
                request.calleeAddr,
                request.value
            ) {

                globalCallStack = Some(struct {
                    runningAs: request.calleeAddr,
                    runningCodeFrom: request.calleeAddr,
                    accountStore: globalAS,
                    runningAsAccount: accountStore_get(globalAS, request.calleeAddr),
                    caller: request.caller,
                    callKind: callKind,
                    calldata: request.calldata,
                    callvalue: request.value,
                    returnInfo: None<ReturnInfo>,
                    memory: bytearray_new(0),
                    evmLogs: evmlogs_empty(),
                    selfDestructQueue: queue_new(),
                    resumeInfo: None<ResumeInfo>,
                    sendQueue: queue_new(),
                    parent: None<any>
                });

                entryPoint();  // start executing the call; should never return
            } else {
                if let Some(gasUsage) = gasAccounting_endTxCharges() {
                    // insufficient balance error
                    emitLog(request.incomingRequest, 4, None<ByteArray>, None<EvmLogs>, Some(gasUsage));
                } else {
                    // unknown error type
                    emitLog(request.incomingRequest, 255, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
                }
                evmCallStack_callHitError(1);
            }
        } else {
            // can't pay for gas error
            emitLog(request.incomingRequest, 3, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
            evmCallStack_callHitError(2);
        }
    } else {
        // no contract at this address, so treat tx as a simple eth transfer

        // increment the caller's sequence number, if caller has sufficient balance
        let acctStore = getGlobalAccountStore();
        if (account_getBalance(accountStore_get(acctStore, request.caller)) >= request.value) {
            setGlobalAccountStore(
                accountStore_set(
                    acctStore,
                    request.caller,
                    account_incrSeqNum(
                        accountStore_get(acctStore, request.caller)
                    )
                )
            );
        }

        if (request.value > 0) {
            // transfer value to destination address
            if let Some(globalAS) = accountStore_transferEthBalance(
                getGlobalAccountStore(),
                request.caller,
                request.calleeAddr,
                request.value
            ) {
                setGlobalAccountStore(globalAS);
                // report success
                emitLog(request.incomingRequest, 0, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
                emptyAvmStack();
                cleanAvmAuxStackAndCall(mainRunLoop,);  // should never return
            } else {
                // insufficient balance error
                emitLog(request.incomingRequest, 4, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
                evmCallStack_callHitError(3);
            }
        } else {
            // tx is transfer of 0 Eth, so just report success
            emitLog(request.incomingRequest, 0, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
            emptyAvmStack();
            cleanAvmAuxStackAndCall(mainRunLoop,);  // should never return
        }
    }
}

public impure func initEvmCallStackForConstructor(
    code: ByteArray,
    evmJumpTable: map<uint, impure func()>,
    startPoint: impure func(),
    request: TxRequestData
) {
    // Set up the call frame for a top-level constructor call, and launch the call's execution.
    // This is called in the context of a new account.
    // The constructor will run, and (if it succeeds) it will return code, which will become the new
    //      code for this new account.

    globalCurrentIncomingRequest = request.incomingRequest;

    // Create a new account to run the constructor code.
    let acctStore = accountStore_set(
        getGlobalAccountStore(),
        request.calleeAddr,
        account_setContractInfo(
            pristineAccount(request.calleeAddr),
            code,
            evmJumpTable,
            startPoint,
            storageMap_new()
        )
    );
    if let Some(uas) = accountStore_transferEthBalance(acctStore, request.caller, request.calleeAddr, request.value) {
        // don't update globalAccountStore; that happens if/when the constructor commits its results later

        globalCallStack = Some(struct {
            runningAs: request.calleeAddr,
            runningCodeFrom: request.calleeAddr,
            accountStore: acctStore,
            runningAsAccount: accountStore_get(acctStore, request.calleeAddr),
            caller: request.caller,
            callKind: 4,
            calldata: request.calldata,
            callvalue: 0,
            returnInfo: None<ReturnInfo>,
            memory: bytearray_new(0),
            evmLogs: evmlogs_empty(),
            selfDestructQueue: queue_new(),
            resumeInfo: None<ResumeInfo>,
            sendQueue: queue_new(),
            parent: None<any>
        });

        if (gasAccounting_startTxCharges(request.maxGas, request.gasPrice, request.caller) != None<()>) {
            startPoint();  // start executing the call; should never return
        }
    } else {
        // can't pay for gas error
        emitLog(request.incomingRequest, 3, None<ByteArray>, None<EvmLogs>, None<GasUsage>);
        evmCallStack_callHitError(4);  // should never return
        panic;
    }
}

public impure func evmCallStack_doCall(
    kind: uint,  // currently handle 0 (call), 2 (delegatecall), 3 (staticcall)
    gas: uint,
    calleeAddr: address,
    balance: uint,
    argsOffset: uint,
    argsLength: uint,
    retOffset: uint,
    retLength: uint,
    resumeCodePoint: func(),  // jump to this to resume the caller
) -> option<bool> {   // returns Some(success) if succeed/fail, or None on error
    let topFrame = globalCallStack?;
    let callee = accountStore_get(topFrame.accountStore, calleeAddr);
    if let Some(startCodePoint) = account_getStartCodePoint(callee) {
        // Create a new callframe for a subcall, and transfer execution to it.
        let availableGas = gasAccounting_pauseTxCharges();
        if (gas > availableGas) {
            gas = availableGas;  // don't give the callee more gas than the caller has
        }

        if (kind == 1) {
            evmCallStack_callHitError(6);
            panic;  // callcode call type not yet implemented
        }

        let callerAddr = topFrame.runningAs;
        let caller = topFrame.runningAsAccount;

        // prepare the caller's frame
        //    this means (1) saving the runningAsAccount into the accountStore, and
        //               (2) saving the resumeInfo so we can resume later
        let stackContents = saveAvmStack();  // must be done as a top level statement
        topFrame = topFrame
            with { accountStore: accountStore_set(topFrame.accountStore, callerAddr, caller) }
            with { resumeInfo: Some(struct {
                       codePoint: resumeCodePoint,
                       stackContents: stackContents,
                       returnDataOffset: retOffset,
                       returnDataNbytes: retLength,
                       callType: kind,
                       savedGas: availableGas-gas,
                   }) };

        // now create a new callframe for the callee
        //     it incorporates the balance transfer from caller to callee
        //          (which is put into the callee frame so it isn't committed unless the call succeeds)
        let runningAsAddr = calleeAddr;
        if (kind == 2) {
            runningAsAddr = callerAddr;  // delegatecall runs as the caller, with callee's code
        }
        let updatedAcctStore = topFrame.accountStore;
        if (balance > 0) {
            updatedAcctStore = accountStore_transferEthBalance(
                updatedAcctStore,
                callerAddr,
                calleeAddr,
                balance
            )?;
        }
        let newTopFrame = struct {
            runningAs: runningAsAddr,
            runningCodeFrom: calleeAddr,
            accountStore: updatedAcctStore,
            runningAsAccount: accountStore_get(updatedAcctStore, runningAsAddr),
            caller: topFrame.runningAs,
            callKind: kind,
            calldata: bytearray_extract(topFrame.memory, argsOffset, argsLength),
            callvalue: balance,
            returnInfo: None<ReturnInfo>,
            memory: bytearray_new(0),
            evmLogs: topFrame.evmLogs,
            selfDestructQueue: topFrame.selfDestructQueue,
            resumeInfo: None<ResumeInfo>,
            sendQueue: topFrame.sendQueue,
            parent: Some(topFrame)
        };

        // there were no errors in the setup, so write the result to global storage
        globalCallStack = Some(newTopFrame);

        // jump to the called code's startCodePoint -- this should never return
        let _ = gasAccounting_resumeTxCharges(gas);
        startCodePoint();  // should never return
    } else {
        // no code at that address, so just do eth transfer
        if (balance > 0) {
            return Some(
                evmCallStack_transferEthFromCurrent(calleeAddr, balance) == Some(())
            );
        } else {
            return Some(true);
        }
    }

    evmCallStack_callHitError(7);
    panic;
}

public impure func evmCallStack_returnFromCall(
    success: bool,
    returnOffset: uint,
    returnLength: uint
) -> option<()> {
    // A call just completed. Commit its effects as appropriate, and return control to its caller.

    let leftoverGas = gasAccounting_pauseTxCharges();  // amount of gas lent to call that wasn't used

    let topFrame = globalCallStack?;
    let memory = topFrame.memory;
    let returnData = bytearray_extract(memory, returnOffset, returnLength);

    if let Some(newTopFrame) = unsafecast<option<EvmCallFrame>>(topFrame.parent) {
        // Returning from a non-top-level call

        topFrame = topFrame with {   // copy cached account back into callframe's main accountStore
            accountStore: accountStore_set(
                topFrame.accountStore,
                topFrame.runningAs,
                topFrame.runningAsAccount
            )
        };

        if (success && (topFrame.callKind != 3)) {   // if call succeeded, and it's not a staticcall
            // copy relevant data back to parent frame
            newTopFrame = newTopFrame
                with { accountStore: topFrame.accountStore }
                with { runningAsAccount: accountStore_get(topFrame.accountStore, newTopFrame.runningAs) }
                with { evmLogs: topFrame.evmLogs }
                with { sendQueue: topFrame.sendQueue };
        }

        // set up returnInfo in caller's frame
        newTopFrame = newTopFrame with { returnInfo: Some(struct{ data: returnData, status: success }) };

        // copy returndata into caller's memory
        let resumeInfo = newTopFrame.resumeInfo?;
        if (returnLength > resumeInfo.returnDataNbytes) {
             returnLength = resumeInfo.returnDataNbytes;
        }
        let newMemory = bytearray_copy(
            returnData,
            0,
            newTopFrame.memory,
            resumeInfo.returnDataOffset,
            returnLength
        );
        newTopFrame = newTopFrame with { memory: newMemory };

        // ready to return to caller
        // save updated EVM callstack state; restore caller's stack; jump to resume address
        globalCallStack = Some(newTopFrame);
        emptyAvmStack();                             // throw away anything that callee left on the stack
        restoreAvmStack(resumeInfo.stackContents,);  // restore the caller's stack
        asm(success,) { };                           // push return code onto the stack, where caller expects it to be
        let _ = gasAccounting_resumeTxCharges(leftoverGas + resumeInfo.savedGas);
        asm(resumeInfo.codePoint,) { jump };         // jump to resume point in caller; this should never return

        evmCallStack_callHitError(8);
        panic;  // shouldn't happen -- previous instruction jumped away
    } else {
        // top-level call completed; will need to return to external caller
        let gasUsage = gasAccounting_endTxCharges()?;
        if (success) {
            if (topFrame.callKind == 4) {
                // Constructor call was successful, so finish setting up the account.
                // The constructor's returndata is EVM code for the contract.
                // Compile that EVM code into AVM, and substitute that in as the code for the contract.
                if let Some(res) = translateEvmCodeSegment(bytestream_new(returnData)) {
                    let (entryPoint, evmJumpTable) = res;

                    // Use the storage left over by the constructor.
                    let storageMap = storageMap_new();
                    if let Some(sm) = account_getAllStorage(topFrame.runningAsAccount) {
                        storageMap = sm;
                    } else {
                        // Somehow the constructor didn't have storage; report error and recover.
                        emitLog(
                            globalCurrentIncomingRequest,
                            6,
                            None<ByteArray>,
                            None<EvmLogs>,
                            Some(gasUsage)
                        );
                        evmCallStack_callHitError(5);  // should never return
                        panic;
                    }

                    // Update the global account store
                    setGlobalAccountStore(
                        accountStore_set(
                            getGlobalAccountStore(),
                            topFrame.runningCodeFrom,
                            account_setContractInfo(
                                pristineAccount(topFrame.runningCodeFrom),
                                returnData,
                                evmJumpTable,
                                entryPoint,
                                storageMap
                            )
                        )
                    );

                    returnData = bytearray_set256(
                        bytearray_new(0),
                        0,
                        uint(topFrame.runningAs)
                    );

                    // emit queued sends
                    sendQueuedMessages(topFrame.sendQueue);

                    // Emit log item reporting success
                    emitLog(
                        globalCurrentIncomingRequest,
                        0,
                        Some(returnData),
                        Some(topFrame.evmLogs),
                        Some(gasUsage)
                    );

                    if (globalCurrentIncomingRequest.kind == 5) {
                        // successfully created a buddy contract -- announce that as a message
                        sendMessage(
                            5,
                            globalCurrentIncomingRequest.sender,
                            bytearray_setByte(bytearray_new(0), 0, 1)
                        );
                    }
                } else {
                    // Compilation of resulting code failed; report an error.
                    emitLog(
                        globalCurrentIncomingRequest,
                        1,
                        None<ByteArray>,
                        None<EvmLogs>,
                        Some(gasUsage)
                    );
                    if (globalCurrentIncomingRequest.kind == 5) {
                        // failed to create a buddy contract -- announce that as a message
                        sendMessage(
                            5,
                            globalCurrentIncomingRequest.sender,
                            bytearray_setByte(bytearray_new(0), 0, 0)
                        );
                    }
                }
            } else {
                if (topFrame.callKind != 3) {
                    // It was a successful tx (not a non-mutating call).
                    // We'll commit the results of the tx

                    // Save cached account back to main accountStore
                    let acctStore = accountStore_set(
                        topFrame.accountStore,
                        topFrame.runningAs,
                        topFrame.runningAsAccount
                    );

                    // Commit the self-destruct events that were requested during the call.
                    let sdq = topFrame.selfDestructQueue;
                    while( ! queue_isEmpty(sdq) ) {
                        let (q, item) = queue_get(sdq)?;
                        sdq = q;
                        let (victim, owner) = unsafecast<(address, address)>(item);
                        acctStore = accountStore_destroyAndTransferBalance(acctStore, victim, owner);
                    }

                    // emit queued sends
                    sendQueuedMessages(topFrame.sendQueue);

                    // Save results back to the main globalAccountStore
                    setGlobalAccountStore(acctStore,);
                }

                // Emit a log item reporting success
                emitLog(
                    globalCurrentIncomingRequest,
                    0,
                    Some(returnData),
                    Some(topFrame.evmLogs),
                    Some(gasUsage)
                );
            }
        } else {
            // Request failed
            emitLog(
                globalCurrentIncomingRequest,
                1,
                Some(returnData),
                None<EvmLogs>,
                Some(gasUsage)
            );
        }

        // Now discard any AVM stack contents and jump back to the main run loop.
        emptyAvmStack();
        cleanAvmAuxStackAndCall(mainRunLoop,);  // should never return
        evmCallStack_callHitError(9);
        panic;
    }
}

func saveAvmStack() -> Stack {
    // pop all items from the AVM stack, push them into a Stack
    let ret = stack_new();
    while( ! asm() bool { stackempty } ) {
        let stackTop = asm() any { };  // pop value from AVM stack
        ret = stack_push(ret, stackTop);
    }
    return ret;
}

public func emptyAvmStack() {
    // discard everything on the AVM stack
    while( ! asm() bool { stackempty } ) {
        let _ = asm() any { };  // pop value from AVM stack
    }
}

func restoreAvmStack(savedStack: Stack) {
    // restore AVM stack state, from a Stack that was create earlier by saveAvmStack
    while( ! stack_isEmpty(savedStack) ) {
        if let Some(res) = stack_pop(savedStack) {
            let (newStack, top) = res;
            savedStack = newStack;
            asm (top,) { };  // push top onto AVM stack
        }
    }
}

public impure func cleanAvmAuxStackAndCall(funcToCall: impure func()) {
    // This cleans the AvmAuxStack, then calls funcToCall.
    // funcToCall must never try to return.

    // Discard everything from the auxstack, except the current callframe (which is on top).
    // Keep the callframe on top of the auxstack (except during asm blocks)
    //       in case the code generator wants to use the callframe
    while ( ! asm() bool { auxpop auxstackempty swap1 auxpush }) {
        asm() {
            auxpop
            auxpop
            pop
            auxpush
        };
    }

    // Discard our callframe, push a fake return address, and jump to funcToCall
    // funcToCall will think somebody called it normally, with an empty auxstack
    asm(funcToCall,) {
        auxpop
        pop
        [0] swap1  // bogus return address, which funcToCall will save in its callframe but will never use
        jump
    };
}

public impure func evmCallStack_isEmpty() -> bool {
    return globalCallStack == None<EvmCallFrame>;
}

public impure func evmCallStack_topFrame() -> option<EvmCallFrame> {
    return globalCallStack;
}

public impure func evmCallStack_oldestCallFrame() -> option<EvmCallFrame> {
    let frame = globalCallStack?;
    loop {
        if let Some(parent) = frame.parent {
            // do "unsafe" cast because compiler doesn't know the true type of parent
            frame = unsafecast<EvmCallFrame>(parent);
        } else {
            return Some(frame);
        }
    }
}

public impure func evmCallStack_runningAsAccount() -> option<Account> {
    return Some((globalCallStack?).runningAsAccount);
}

public impure func evmCallStack_runningCodeFromAccount() -> option<Account> {
    return Some(evmCallFrame_runningCodeFromAccount(globalCallStack?));
}

public impure func evmCallStack_runningAsAccountAndAddr() -> option<(Account, address)> {
    let topFrame = globalCallStack?;
    return Some((topFrame.runningAsAccount, topFrame.runningAs));
}

public impure func evmCallStack_writeRunningAsAccount(acct: Account) -> bool {
    if let Some(topFrame) = globalCallStack {
        globalCallStack = Some(topFrame with { runningAsAccount: acct });
        return true;
    } else {
        return false;
    }
}

public impure func evmCallStack_getTopFrameReturnData() -> option<ByteArray> {
    return Some(((globalCallStack?).returnInfo?).data);
}

public impure func evmCallStack_getAccount(addr: address) -> option<Account> {
    let topFrame = globalCallStack?;
    if (topFrame.runningAs == addr) {
        return Some(topFrame.runningAsAccount);
    } else {
        return Some(accountStore_get(topFrame.accountStore, addr));
    }
}

public impure func evmCallStack_setAccount(addr: address, acct: Account) -> bool {
    if let Some(topFrame) = globalCallStack {
        if (topFrame.runningAs == addr) {
            globalCallStack = Some(topFrame with { runningAsAccount: acct });
        } else {
            globalCallStack = Some(topFrame with {
                accountStore: accountStore_set(topFrame.accountStore, addr, acct)
            });
        }
        return true;
    } else {
        return false;
    }
}

public impure func evmCallStack_getTopFrameMemoryOrDie() -> ByteArray {
    if let Some(topFrame) = globalCallStack {
        return topFrame.memory;
    } else {
        evmCallStack_callHitError(10);
        panic;
    }
}

public impure func evmCallStack_setTopFrameMemory(mem: ByteArray) -> bool {
    if let Some(topFrame) = globalCallStack {
        globalCallStack = Some(topFrame with { memory: mem });
        return true;
    } else {
        return false;
    }
}

public impure func evmCallStack_queueMessage(msg: any) {
    if let Some(topFrame) = globalCallStack {
        globalCallStack = Some(
            topFrame with {
                sendQueue: queue_put(topFrame.sendQueue, msg)
            }
        );
        return;
    }

    evmCallStack_callHitError(14);
}

public impure func evmCallStack_transferEthFromCurrent(
    dest: address,
    amount: uint,
) -> option<()> {
    // Try to transfer eth from the current account to dest.
    // Return Some(()) if transfer succeeds, or None otherwise.

    let topFrame = globalCallStack?;
    if (topFrame.runningAs == dest) {
        return None;   // can't do a self-transfer
    }
    let curAcct = topFrame.runningAsAccount;
    let curBalance = account_getBalance(curAcct);
    if (curBalance < amount) {
        return None;   // insufficient funds
    }
    topFrame = topFrame with {
        runningAsAccount: account_setBalance(curAcct, curBalance-amount)
    };
    let otherAcct = accountStore_get(topFrame.accountStore, dest);
    topFrame = topFrame with {
        accountStore: accountStore_set(
            topFrame.accountStore,
            dest,
            account_setBalance(
                otherAcct,
                account_getBalance(otherAcct) + amount
            )
        )
    };
    globalCallStack = Some(topFrame);
    return Some(());
}

public impure func evmCallStack_setTopFrameStorageCell(offset: uint, value: uint) -> option<()> {
    let topFrame = globalCallStack?;
    globalCallStack = Some(topFrame with {
        runningAsAccount: account_setStorageCell(
            topFrame.runningAsAccount,
            offset,
            value
        )?
    });
    return Some(());
}

public impure func evmCallStack_addEvmLogToCurrent(item: any) -> option<()> {
    let topFrame = globalCallStack?;
    item = asm(0, item, topFrame.runningAs) any { tset };
    let newLogs = evmlogs_appendAny(topFrame.evmLogs, item);
    globalCallStack = Some(
        topFrame with {
            evmLogs: newLogs
        }
    );
    return Some(());
}

public impure func evmCallStack_selfDestructCurrentAccount(owner: address) {
    if let Some(topFrame) = globalCallStack {
        globalCallStack = Some(
            topFrame with {
                selfDestructQueue: queue_put(
                    topFrame.selfDestructQueue,
                    (topFrame.runningAs, owner)
                )
            }
        );
    }
}

public impure func evmCallStack_cloneContract(addr: address) -> option<address> {
    let (seqNum, acct) = account_fetchAndIncrSeqNum(
        evmCallStack_getAccount(addr)?
    );
    if ( ! evmCallStack_setAccount(addr, acct)) {
        return None;
    }

    let newAddr = address(hash(hash(addr), hash(seqNum)));

    let topFrame = globalCallStack?;
    let acctStore = topFrame.accountStore;
    if (addr == topFrame.runningAs) {
        // we're touching the cached account, so copy it back into the acctStore before cloneContract
        //     and we'll copy it back out after cloneContract
        acctStore = accountStore_set(acctStore, topFrame.runningAs, topFrame.runningAsAccount);
    }
    acctStore = accountStore_cloneContract(acctStore, addr, newAddr)?;
    if (addr == topFrame.runningAs) {
        topFrame = topFrame with { runningAsAccount: accountStore_get(acctStore, topFrame.runningAs) };
    }
    topFrame = topFrame with { accountStore: acctStore };
    globalCallStack = Some(topFrame);

    return Some(newAddr);
}

public func evmCallFrame_runningAsAddress(frame: EvmCallFrame) -> address {
    return frame.runningAs;
}

public func evmCallFrame_runningAsAccount(frame: EvmCallFrame) -> Account {
    return frame.runningAsAccount;
}

public func evmCallFrame_runningCodeFromAccount(frame: EvmCallFrame) -> Account {
    return evmCallFrame_getAccount(frame, frame.runningCodeFrom);
}

public func evmCallFrame_getCaller(frame: EvmCallFrame) -> address {
    return frame.caller;
}

public func evmCallFrame_getAccount(frame: EvmCallFrame, addr: address) -> Account {
    if (addr == frame.runningAs) {
        return frame.runningAsAccount;
    } else {
        return accountStore_get(frame.accountStore, addr);
    }
}

public func evmCallFrame_getMemory(frame: EvmCallFrame) -> ByteArray {
    return frame.memory;
}

public func evmCallFrame_getCallvalue(frame: EvmCallFrame) -> uint {
    return frame.callvalue;
}

public func evmCallFrame_getCalldata(frame: EvmCallFrame) -> ByteArray {
    return frame.calldata;
}

public func evmCallFrame_getEvmLogs(frame: EvmCallFrame) -> EvmLogs {
    return frame.evmLogs;
}

public func evmCallFrame_getResumeCodePoint(frame: EvmCallFrame) -> option<func()> {
    return Some((frame.resumeInfo?).codePoint);
}

public func evmCallFrame_getSelfDestructQueue(frame: EvmCallFrame) -> Queue {
    return frame.selfDestructQueue;
}

public func evmCallFrame_getParent(frame: EvmCallFrame) -> option<EvmCallFrame> {
    return unsafecast<option<EvmCallFrame>>(frame.parent);
    // unsafecast is safe because underlying type is really EvmCallFrame
    //    (compiler doesn't know because it doesn't accept recursive types)
}

public impure func evmCallStack_callHitError(errInfo: any) {
    asm((664, errInfo),) { debugprint };
    if (evmCallStack_returnFromCall(false, 0, 0) == None<()>) {
        // something has gone seriously wrong with the evmCallStack
        // recover by clearing the evmCallStack, refunding unused gas, and jumping back to the error handler
        globalCallStack = None<EvmCallFrame>;
        let _ = gasAccounting_endTxCharges();

        errorHandler();  // should never return
        panic;
    }
}