//
// Copyright 2020-2021, Offchain Labs, Inc. All rights reserved.
//

use accounts::AccountStore;
use accounts::Account;
use evmlogs::EvmLogs;
use std::queue::Queue;
use std::bytearray::ByteArray;
use std::stack::Stack;
use messages::TxRequestData;

use errorHandler::errorHandler;

use accounts::safeGetGlobalAccountStore;
use accounts::safeSetGlobalAccountStore;
use accounts::getGlobalAccountStore;
use accounts::setGlobalAccountStore;
use accounts::accountStore_changeNumContracts;
use accounts::accountStore_get;
use accounts::accountStore_set;
use accounts::accountStore_getRetryBuffer;
use accounts::accountStore_setRetryBuffer;
use accounts::accountStore_transferEthBalance;
use accounts::accountStore_destroyAccount;
use accounts::accountStore_createOrAddCodeRef;
use accounts::accountStore_payFromEscrow;
use accounts::account_setStorageCell;
use accounts::account_getBalance;
use accounts::account_getAllStorage;
use accounts::account_getStartCodePoint;
use accounts::account_setContractInfo;
use accounts::account_incrSeqNum;
use accounts::account_getStorageSize;
use accounts::account_usesOriginalStorageGasAlloc;

use chainParameters::chainParams_getOrDie;

use evmOps::evmOp_callAndReturn;

use evmlogs::evmlogs_empty;
use evmlogs::evmlogs_appendAny;

use std::avmcodebuilder::AvmCodePoint;

use std::bytearray::bytearray_new;
use std::bytearray::bytearray_size;
use std::bytearray::bytearray_extract;
use std::bytearray::bytearray_copy;
use std::bytearray::bytearray_getByte;
use std::bytearray::bytearray_set256;
use std::bytestream::bytestream_new;

use std::storageMap::storageMap_new;

use std::queue::queue_new;
use std::queue::queue_isEmpty;
use std::queue::queue_get;
use std::queue::queue_put;

use std::safeMath::safeAdd;
use std::safeMath::safeMul;

use std::stack::stack_new;
use std::stack::stack_isEmpty;
use std::stack::stack_push;
use std::stack::stack_pop;
use std::stack::stack_discardDeepestItems;

use gasAccounting::TxFeeStats;
use gasAccounting::gasAccounting_startTxCharges;
use gasAccounting::gasAccounting_endTxCharges;
use gasAccounting::gasAccounting_pauseTxCharges;
use gasAccounting::gasAccounting_resumeTxCharges;
use gasAccounting::txFeeStats_zero;
use gasAccounting::getAddressForReserveFundsDeposit;
use gasAccounting::deferredPayments_apply;
use gasAccounting::gasAccounting_addToGasPool;
use gasAccounting::gasAccounting_chargeCurrentTxForStorage;
use gasAccounting::gasAccounting_recordAllocationForRefund;

use std::codeSegment::getDummyAcceptContractCode;
use std::codeSegment::translateEvmCodeSegment;

use output::emitTxReceipt;
use output::queueMessageForSend;

use output::outbox_append;
use output::sendQueuedMessages;

use inbox::IncomingRequest;
use inbox::inbox_currentArbBlockNumber;
use inbox::inbox_currentEthBlockNumber;
use inbox::inbox_currentTimestamp;
use inbox::mainRunLoop;

use retrybuffer::RetryBuffer;
use retrybuffer::RetryableTx;
use retrybuffer::retryableTx_getOriginalSender;

use tracing::evmTracer_clear;
use tracing::evmTracer_pushCall;
use tracing::evmTracer_pushReturnRevert;
use tracing::evmTracer_pushCallAndResultNoExecution;


// This callframe is used to represent the state of an EVM call in progress.
// If the call succeeds, we'll copy the call's state back into the caller as the new
//        state, but if the call fails we'll discard the state from the callframe.
// (For staticcalls, we will discard state even if the call succeeds, as the EVM spec requires.)
type EvmCallFrame = struct {
    runningAs: address,                 // call is running in the execution/security context of this address
    runningCodeFrom: address,           // call is running code associated with this address
    accountStore: AccountStore,         // accountStore to use while executing this call
    runningAsAccount: Account,          // cache of accountStore[runningAs]
    caller: address,                    // who called this
    isConstructor: bool,                // true iff this is a constructor
    static: bool,                       // static flag, per EIP-214
    calldata: ByteArray,                // calldata passed in by our caller
    callvalue: uint,                    // Eth value given to this call by its caller
    returnInfo: option<ReturnInfo>,     // result of last subcall made by this call (if any)
    memory: ByteArray,                  // EVM memory of this call
    maxMemoryOffsetTouched: uint,       // maximum memory offset read/written by this call (in bytes)
    storageAllocations: uint,           // number of EVM storage cells allocated, including by non-reverting child calls
    revertOnStorageWrite: bool,         // if true, revert if the EVM code tries to write to storage
    evmLogs: EvmLogs,                   // EVM logs emitted so far in current top-level tx
    selfDestructQueue: Queue,           // set of self-destruct directives, so far in current top-level tx
    resumeInfo: option<ResumeInfo>,     // state will be saved here if this call makes a sub-call
    sendQueue: Queue,                   // outgoing messages created so far in current top-level tx
    sendOnFailure: option<ByteArray>,   // message to send if this call fails
    parent: option<EvmCallFrame>,       // call-frame that created this one, or None if this is a top-level call
};

type ReturnInfo = struct {  // information about a call that previously completed
    data: ByteArray,
    status: bool,     // true iff call succeeded
};

type ResumeInfo = struct {            // information used to resume a call after a subcall returns
    codePoint: func(),                // where to resume execution
    stackContents: Stack,             // saved contents of stack
    auxStackContents: option<Stack>,  // saved contents of aux stack; None means to clear the auxstack on resume
    returnDataOffset: uint,           // where in memory the returndata from subcall should be put
    returnDataNbytes: uint,           // max amount of returndata to copy into caller's memory
    callType: uint,                   // call type of the subcall
    savedAPGas: uint,                 // how much of the caller's all-purpose gas was not lent to the subcall
    savedStorageGas: uint,            //                          storage-only
    givenAPGas: uint,                 // how much of the caller's all-purpose gas was lent to the subcall
    givenStorageGas: uint,            //                          storage-only
};

var globalCallStack: option<EvmCallFrame>;   // call frame of currently running call, if any
var globalCurrentTxRequest: TxRequestData;  // request that launched the top-level call

type IncomingRequestAndLogs = struct {
    req: IncomingRequest,
    evmLogs: EvmLogs,
    originalSender: address,
};

var globalCurrentRetryableRequest: option<IncomingRequestAndLogs>;  // describes the retryable request we're currently doing, if any


public write func evmCallStack_init() {
    globalCallStack = None<EvmCallFrame>;
    globalCurrentRetryableRequest = None<IncomingRequestAndLogs>;
    returnFromCallNestingDepth = 0;
}

public view write throw func getRetryBufferInCurrentContext() -> RetryBuffer {
    let astore = if let Some(frame) = globalCallStack {
        frame.accountStore
    } else {
        safeGetGlobalAccountStore()
    };
    accountStore_getRetryBuffer(astore)
}

public view write throw func setRetryBufferInCurrentContext(rbuf: RetryBuffer) {
    if let Some(topFrame) = globalCallStack {
        set topFrame.accountStore = accountStore_setRetryBuffer(topFrame.accountStore, rbuf);
        globalCallStack = Some(topFrame);
    } else {
        safeSetGlobalAccountStore(
            accountStore_setRetryBuffer(safeGetGlobalAccountStore(), rbuf)
        );
    }
}

public view func evmCallStack_getCurrentTxFeeStats() -> TxFeeStats {
    globalCurrentTxRequest.feeStats
}

public view func evmCallStack_isEmpty() -> bool {
    globalCallStack == None<EvmCallFrame>
}

public view func evmCallStack_currentTxRequestGasBid() -> uint {
    globalCurrentTxRequest.gasPrice
}

public view write throw func evmCallStack_addStorageCharge(units: uint, refundInfo: option<(address, uint)>) {
    if let Some(topFrame) = globalCallStack {
        set topFrame.storageAllocations = topFrame.storageAllocations + units;
        globalCallStack = Some(topFrame);

        let remainingArbGasToCharge = gasAccounting_chargeCurrentTxForStorage(units);
        let avmGasPerArbGas = chainParams_getOrDie(const::Atom_Param_AvmGasPerArbGas);
        let avmGasToBurn = remainingArbGasToCharge * avmGasPerArbGas;
        let avmGasLeft = getGas();
        if avmGasToBurn < avmGasLeft {
            if let Some(ri) = refundInfo {
                let (addr, storageIndex) = ri;
                gasAccounting_recordAllocationForRefund(addr, storageIndex);
            }
        } else {
            avmGasToBurn = avmGasLeft-1;
        }
        setGas(avmGasLeft - avmGasToBurn);
    }
}

public view func evmCallStack_stackDepth() -> uint {
    let depth = 0;
    let maybeFrame = globalCallStack;
    loop {
        if let Some(frame) = maybeFrame {
            depth = depth + 1;
            maybeFrame = frame.parent;
        } else {
            return depth;
        }
    }
}

public view func evmCallStack_inRetryable() -> bool {
    (globalCallStack != None<EvmCallFrame>) && (globalCurrentRetryableRequest != None<IncomingRequestAndLogs>)
}

public view func evmCallStack_inStaticCall() -> bool {
    if let Some(topFrame) = globalCallStack {
        topFrame.static
    } else {
        false
    }
}

public view func evmCallStack_stackInfo() -> (uint, (address, address), (address, address)) {
    if let Some(topFrame) = globalCallStack {
        let sndRunningAs = address(0);
        let sndRunningCodeFrom = address(0);
        if let Some(sndFrame) = unsafecast<option<EvmCallFrame> >(topFrame.parent) {
            sndRunningAs = sndFrame.runningAs;
            sndRunningCodeFrom = sndFrame.runningCodeFrom;
        }
        (
            globalCurrentTxRequest.incomingRequest.requestId,
            (topFrame.runningAs, topFrame.runningCodeFrom),
            (sndRunningAs, sndRunningCodeFrom),
        )
    } else {
        (0, (address(0), address(0)), (address(0), address(0)))
    }
}

public view write throw func initEvmCallStack(
    callKind: uint,
    request: TxRequestData,
    sendOnFailure: option<ByteArray>,
    callvalueEscrowKey: option<uint>,
) {
    evmTracer_clear();
    evmTracer_pushCall(
        callKind,
        request.calldata,
        request.value,
        request.caller,
        request.calleeAddr,
        request.maxGas,
        request.gasPrice,
    );

    if let Some(entryPoint) = account_getStartCodePoint(
        accountStore_get(
            safeGetGlobalAccountStore(),
            request.calleeAddr
        )
    ) {
        // call is to a contract

        globalCurrentTxRequest = request;
        globalCurrentRetryableRequest = None<IncomingRequestAndLogs>;

        let (startTxResult, acctStore) = if request.maxGas < const::Charging_MinArbGasForContractTx {
            (const::TxResultCode_belowMinimumTxGas, safeGetGlobalAccountStore())
        } else {
            let (result, astore) = gasAccounting_startTxCharges(request, safeGetGlobalAccountStore());
            safeSetGlobalAccountStore(astore);
            (result, astore)
        };

        if startTxResult == const::TxResultCode_success {
            if request.seqNum != None<uint> {
                // call carried a sequence number, which has already been checked
                // now increment the caller's sequence number
                acctStore = accountStore_set(
                    acctStore,
                    request.caller,
                    account_incrSeqNum(
                        accountStore_get(acctStore, request.caller)
                    )
                );
            }
            safeSetGlobalAccountStore(acctStore);

            globalCurrentTxRequest = request;
            globalCurrentRetryableRequest = None<IncomingRequestAndLogs>;

            // pay callvalue from caller to the called contract
            // payment will only be recorded inside the new callframe, so it will be nullified if the call reverts
            if let Some(globalAS) = ethTransferOrGrant(
                safeGetGlobalAccountStore(),
                request.caller,
                request.calleeAddr,
                request.value,
                callvalueEscrowKey,
            ) {
                // now create an EvmCallFrame for the new call, and jump to the callee's code
                globalCallStack = Some(struct {
                    runningAs: request.calleeAddr,
                    runningCodeFrom: request.calleeAddr,
                    accountStore: globalAS,
                    runningAsAccount: accountStore_get(globalAS, request.calleeAddr),
                    caller: request.caller,
                    isConstructor: false,
                    static: false,
                    calldata: request.calldata,
                    callvalue: request.value,
                    returnInfo: None,
                    memory: bytearray_new(0),
                    maxMemoryOffsetTouched: 0,
                    storageAllocations: 0,
                    revertOnStorageWrite: false,
                    evmLogs: evmlogs_empty(),
                    selfDestructQueue: queue_new(),
                    resumeInfo: None,
                    sendQueue: queue_new(),
                    sendOnFailure: sendOnFailure,
                    parent: None,
                });

                emptyAvmStack();
                asm(entryPoint) { jump };
            } else {
                // caller didn't have enough funds
                if let Some(res) = gasAccounting_endTxCharges(0, request.feeStats, None) {
                    // insufficient balance error
                    let (_, gasUsage, feeStats, payments) = res;
                    if let Some(uas) = deferredPayments_apply(safeGetGlobalAccountStore(), payments) {
                        safeSetGlobalAccountStore(uas);
                    }
                    evmTracer_pushReturnRevert(const::TxResultCode_insufficientBalance, bytearray_new(0), 0);
                    emitTxReceipt(
                        request.incomingRequest,
                        const::TxResultCode_insufficientBalance,
                        None,
                        None,
                        Some(gasUsage),
                        feeStats,
                        true,
                        request.originalCaller,
                    );
                } else {
                    // something strange happened, so return unknown error type
                    evmTracer_pushReturnRevert(const::TxResultCode_unknownFailure, bytearray_new(0), 0);
                    emitTxReceipt(
                        request.incomingRequest,
                        const::TxResultCode_unknownFailure,
                        None,
                        None,
                        None,
                        request.feeStats,
                        true,
                        request.originalCaller,
                    );
                }
            }
        } else {
            // can't pay for gas error
            evmTracer_pushReturnRevert(startTxResult, bytearray_new(0), 0);
            emitTxReceipt(
                request.incomingRequest,
                startTxResult,
                None,
                None,
                None,
                request.feeStats,
                true,
                request.originalCaller,
            );
        }
    } else {
        // call is to an address with no contract, so treat it as a simple eth transfer

        if request.seqNum != None<uint> {
            // this call carries a sequence number, which has already been checked
            // now increment the caller's sequence number
            let acctStore = safeGetGlobalAccountStore();
            acctStore = accountStore_set(
                acctStore,
                request.caller,
                account_incrSeqNum(
                    accountStore_get(acctStore, request.caller)
                )
            );
            safeSetGlobalAccountStore(acctStore);
        }

        if request.value > 0 {
            // transfer value to destination address
            if let Some(globalAS) = ethTransferOrGrant(
                safeGetGlobalAccountStore(),
                request.caller,
                request.calleeAddr,
                request.value,
                callvalueEscrowKey,
            ) {
                if callKind != const::EVMCallType_staticcall {  // commit the transfer, unless it's a static call
                    safeSetGlobalAccountStore(globalAS);
                }

                // report success
                evmTracer_pushReturnRevert(const::TxResultCode_success, bytearray_new(0), 0);
                emitTxReceipt(
                    request.incomingRequest,
                    const::TxResultCode_success,
                    None,
                    None,
                    None,
                    request.feeStats,
                    true,
                    request.originalCaller,
                );
            } else {
                // insufficient balance error
                evmTracer_pushReturnRevert(const::TxResultCode_insufficientBalance, bytearray_new(0), 0);
                emitTxReceipt(
                    request.incomingRequest,
                    const::TxResultCode_insufficientBalance,
                    None,
                    None,
                    None,
                    request.feeStats,
                    true,
                    request.originalCaller,
                );
            }
        } else {
            // tx is transfer of 0 Eth, so just report success
            evmTracer_pushReturnRevert(const::TxResultCode_success, bytearray_new(0), 0);
            emitTxReceipt(
                request.incomingRequest,
                const::TxResultCode_success,
                None,
                None,
                None,
                request.feeStats,
                true,
                request.originalCaller,
            );
        }
    }

    // We should only reach this point if there was an error that prevented starting a tx.
    // A tx receipt with appropriate failure code should have been emitted.
    // Now clean up and return to the main run loop.
    emptyAvmStack();
    cleanAvmAuxStackAndCall(mainRunLoop, true);
    //NOTREACHED
}

public view write throw func initEvmCallStackForConstructor(
    code: ByteArray,
    request: TxRequestData,
    callvalueEscrowKey: option<uint>,
) {
    // Set up the call frame for a top-level constructor call, and launch the call's execution.
    // This is called in the context of a new account.
    // The constructor will run, and (if it succeeds) it will return code, which will become the new
    //      code for this new account.

    evmTracer_clear();
    evmTracer_pushCall(
        const::EVMCallType_call,
        request.calldata,
        request.value,
        request.caller,
        request.calleeAddr,
        request.maxGas,
        request.gasPrice,
    );

    globalCurrentTxRequest = request with { isConstructor: true };
    globalCurrentRetryableRequest = None<IncomingRequestAndLogs>;

    // Create an accountStore with the caller's sequence number incremented, and commit it
    let acctStore = safeGetGlobalAccountStore();
    acctStore = accountStore_set(
        acctStore,
        request.caller,
        account_incrSeqNum(
            accountStore_get(acctStore, request.caller)
        )
    );
    safeSetGlobalAccountStore(acctStore);

    let (startTxResult, *acctStore) = if request.maxGas < const::Charging_MinArbGasForContractTx {
        (const::TxResultCode_belowMinimumTxGas, acctStore)
    } else {
        let (result, astore) = gasAccounting_startTxCharges(request, acctStore);
        safeSetGlobalAccountStore(astore);
        (result, astore)
    };

    if startTxResult == const::TxResultCode_success {
        if let Some(uas) = ethTransferOrGrant(
            acctStore,
            request.caller,
            request.calleeAddr,
            request.value,
            callvalueEscrowKey,
        ) {
            acctStore = uas;

            // set up a fake stack frame, so that errors in EVM->AVM translation will cause proper failure receipts
            globalCallStack = Some(struct {
                runningAs: request.calleeAddr,
                runningCodeFrom: request.calleeAddr,
                accountStore: acctStore,
                runningAsAccount: accountStore_get(acctStore, request.calleeAddr),
                caller: request.caller,
                isConstructor: true,
                static: false,
                calldata: request.calldata,
                callvalue: request.value,
                returnInfo: None,
                memory: bytearray_new(0),
                maxMemoryOffsetTouched: 0,
                storageAllocations: 0,
                revertOnStorageWrite: false,
                evmLogs: evmlogs_empty(),
                selfDestructQueue: queue_new(),
                resumeInfo: None,
                sendQueue: queue_new(),
                sendOnFailure: None,
                parent: None,
            });

            // translate the constructor's EVM code into AVM code
            let (startPoint, evmJumpTable, _) = translateEvmCodeSegment(bytestream_new(code), false);

            // Create a new account to run the constructor code.
            acctStore = accountStore_set(
                acctStore,
                request.calleeAddr,
                account_setContractInfo(
                    accountStore_get(acctStore, request.calleeAddr),
                    code,
                    evmJumpTable,
                    getDummyAcceptContractCode(),
                    storageMap_new(),
                    true,
                )
            );

            // set up EvmCallFrame for running the constructor
            globalCallStack = Some(struct {
                runningAs: request.calleeAddr,
                runningCodeFrom: request.calleeAddr,
                accountStore: acctStore,
                runningAsAccount: accountStore_get(acctStore, request.calleeAddr),
                caller: request.caller,
                isConstructor: true,
                static: false,
                calldata: request.calldata,
                callvalue: request.value,
                returnInfo: None,
                memory: bytearray_new(0),
                maxMemoryOffsetTouched: 0,
                storageAllocations: 0,
                revertOnStorageWrite: false,
                evmLogs: evmlogs_empty(),
                selfDestructQueue: queue_new(),
                resumeInfo: None,
                sendQueue: queue_new(),
                sendOnFailure: None,
                parent: None,
            });

            emptyAvmStack();
            asm(startPoint) { jump };
            error;
        } else {
            // caller doesn't have the funds to provide callvalue
            evmTracer_pushReturnRevert(const::TxResultCode_insufficientBalance, bytearray_new(0), 0);
            emitTxReceipt(
                request.incomingRequest,
                const::TxResultCode_insufficientBalance,
                None,
                None,
                None,
                request.feeStats,
                true,
                request.originalCaller,
            );
            error;
        }
    } else {
        // can't pay for gas error
        evmTracer_pushReturnRevert(startTxResult, bytearray_new(0), 0);
        emitTxReceipt(
            request.incomingRequest,
            startTxResult,
            None,
            None,
            None,
            request.feeStats,
            true,
            request.originalCaller,
        );
    }

    // We should only reach this point if there was an error that prevented starting a tx.
    // A tx receipt with appropriate failure code should have been emitted.
    // Now clean up and return to the main run loop.
    emptyAvmStack();
    cleanAvmAuxStackAndCall(mainRunLoop, true);
    //NOTREACHED
}

// Make a tx call from within another tx
public view write throw func evmCallStack_doCall(
    kind: uint,  // call types are: 0 (call), 1 (callcode), 2 (delegatecall), 3 (staticcall)
    isConstructor: bool,
    gas: uint,
    calleeAddr: address,
    balance: uint,
    argsOffset: uint,
    argsLength: uint,
    retOffset: uint,
    retLength: uint,
    resumeCodePoint: func(),          // jump to this to resume the caller
    resumeAuxStack: option<Stack>,    // aux stack contents to restore on resume, if any
    callvalueEscrowKey: option<uint>, // escrow key that supplies the callvalue (otherwise caller supplies it)
    overrideStartPoint: option<AvmCodePoint>,
) -> option<bool> {   // returns Some(success) if succeed/fail, or None on error
    if (kind != const::EVMCallType_call)
        && (kind != const::EVMCallType_staticcall)
        && (uint(calleeAddr) >= const::MinArbitrumPrecompile)
        && (uint(calleeAddr) <= const::MaxArbitrumPrecompile) {
        return Some(false);
    }
    let topFrame = globalCallStack?;
    let callee = accountStore_get(topFrame.accountStore, calleeAddr);
    let maybeStartPoint = if let Some(osp) = overrideStartPoint {
        overrideStartPoint
    } else {
        account_getStartCodePoint(callee)
    };

    if let Some(startCodePoint) = maybeStartPoint {
        let callerAddr = topFrame.runningAs;
        let caller = topFrame.runningAsAccount;

        // Create a new callframe for a subcall, and transfer execution to it.
        let (availableAPGas, availableStorageGas) = gasAccounting_pauseTxCharges();
        if balance > 0 {
            // Add a stipend, charged to the caller, if non-zero value is transferred.
            // This is needed because Ethereum provides a stipend, and some application code depends on that.
            // The size of our stipend was chosen experimentally, to make sure a call that will run on Ethereum will run here.
            gas = safeAdd(gas, chainParams_getOrDie(const::Atom_Param_ArbitrumNonZeroBalanceCallStipend));
        }
        if gas > 63*availableAPGas/64 {
            gas = 63*availableAPGas/64;  // per EVM spec, don't give the callee more than 63/64 of the caller's gas
        }
        let storageGas = if account_usesOriginalStorageGasAlloc(caller) {
            availableStorageGas
        } else if availableAPGas == 0 {
            0
        } else {
            gas * availableStorageGas / availableAPGas
        };

        // prepare the caller's frame
        //    this means (1) saving the runningAsAccount into the accountStore, and
        //               (2) saving the resumeInfo so we can resume later
        let stackContents = saveAvmStack();  // must be done as a top level statement
        set topFrame.accountStore = accountStore_set(topFrame.accountStore, callerAddr, caller);
        set topFrame.resumeInfo = Some(struct {
            codePoint: resumeCodePoint,
            stackContents: stackContents,
            auxStackContents: resumeAuxStack,
            returnDataOffset: retOffset,
            returnDataNbytes: retLength,
            callType: kind,
            savedAPGas: availableAPGas-gas,
            savedStorageGas: availableStorageGas-storageGas,
            givenAPGas: gas,
            givenStorageGas: storageGas,
        });

        // now create a new callframe for the callee
        //     it incorporates the balance transfer from caller to callee
        //          (which is put into the callee frame so it isn't committed unless the call succeeds)
        let runningAsAddr = calleeAddr;
        let newCallerAddr = topFrame.runningAs;
        if (kind == const::EVMCallType_callcode) || (kind == const::EVMCallType_delegatecall) {
            runningAsAddr = callerAddr;  // callcode and delegatecall run as the caller, with callee's code
            if kind == const::EVMCallType_delegatecall {
                newCallerAddr = topFrame.caller;  // delegatecall inherits the caller of its parent
            }
        }
        if (calleeAddr != runningAsAddr)
            && (uint(calleeAddr) >= const::MinArbitrumPrecompile)
            && (uint(calleeAddr) <= const::MaxArbitrumPrecompile)
        {
            let _ = gasAccounting_resumeTxCharges(availableAPGas, availableStorageGas)?;
            return Some(false);
        }
        let updatedAcctStore = topFrame.accountStore;
        if balance > 0 {
            if let Some(uas) = ethTransferOrGrant(
                updatedAcctStore,
                callerAddr,
                calleeAddr,
                balance,
                callvalueEscrowKey,
            ) {
                updatedAcctStore = uas;
            } else {
                let _ = gasAccounting_resumeTxCharges(availableAPGas, availableStorageGas)?;
                restoreAvmStack(stackContents);
                return Some(false);
            }
        } else if kind == const::EVMCallType_delegatecall {
            // delegatecall inherits the callvalue of its parent
            // but we don't need to do a transfer because it's running as the same account
            balance = topFrame.callvalue;
        }
        let newTopFrame = struct {
            runningAs: runningAsAddr,
            runningCodeFrom: calleeAddr,
            accountStore: updatedAcctStore,
            runningAsAccount: accountStore_get(updatedAcctStore, runningAsAddr),
            caller: newCallerAddr,
            isConstructor: isConstructor,
            static: topFrame.static || (kind == const::EVMCallType_staticcall),
            calldata: bytearray_extract(topFrame.memory, argsOffset, argsLength),
            callvalue: balance,
            returnInfo: None,
            memory: bytearray_new(0),
            maxMemoryOffsetTouched: 0,
            storageAllocations: topFrame.storageAllocations,
            revertOnStorageWrite: // disallow storage write if gas provided < EVM gas cost of storage write
                                  //       if balance == 0, disallow if gas < EVM gas cost of storage write
                                  //       if balance > 0, disallow if gas (before 20000 stipend) + EVM stipend
                                  //                           would have been less than EVM gas cost of storage write
                                  topFrame.revertOnStorageWrite
                                  || ((balance == 0) && (gas < const::EVMWriteL1GasCost))
                                  || ((balance > 0) && (gas <= (const::EVMWriteL1GasCost
                                                                + chainParams_getOrDie(const::Atom_Param_ArbitrumNonZeroBalanceCallStipend)
                                                                - const::EVMNonZeroBalanceCallStipend))),
            evmLogs: topFrame.evmLogs,
            selfDestructQueue: topFrame.selfDestructQueue,
            resumeInfo: None,
            sendQueue: topFrame.sendQueue,
            sendOnFailure: None,
            parent: Some(topFrame)
        };

        // there were no errors in the setup, so write the result to the global stack
        globalCallStack = Some(newTopFrame);

        // write trace info
        evmTracer_pushCall(
            kind,
            newTopFrame.calldata,
            newTopFrame.callvalue,
            newTopFrame.caller,
            newTopFrame.runningCodeFrom,
            gas,
            globalCurrentTxRequest.gasPrice,
        );

        // jump to the called code's startCodePoint -- this should never return
        let _ = gasAccounting_resumeTxCharges(gas, storageGas)?;
        emptyAvmStack();
        asm(startCodePoint) { jump };
    } else {
        // no code at destination address, so just do an eth transfer
        let success = (balance == 0) ||
            if let Some(escrowKey) = callvalueEscrowKey {
                evmCallStack_transferEthFromEscrow(escrowKey, calleeAddr, balance) == Some(())
            } else {
                evmCallStack_transferEthFromCurrent(calleeAddr, balance) == Some(())
            }
        ;

        // save returndata and status
        globalCallStack = Some(globalCallStack? with {
            returnInfo: Some(struct {
                data: bytearray_new(0),
                status: success,
            })
        });

        evmTracer_pushCallAndResultNoExecution(
            kind,
            bytearray_extract(topFrame.memory, argsOffset, argsLength),
            balance,
            topFrame.runningAs,
            calleeAddr,
            gas,
            globalCurrentTxRequest.gasPrice,
            if success { const::TxResultCode_success } else { const::TxResultCode_revert },
        );
        return Some(success);
    }

    evmCallStack_callHitError(7);
    error
}

// returnFromCallNestingDepth keeps track of the nesting depth of evmCallStack_returnFromCalls
// it is incremented on every entry to that function, and set to zero on every exit
// If its value gets above a threshold, this means we must be in an error loop, so we exit the current tx abruptly
//        and get back to a safe state.
var returnFromCallNestingDepth: uint;

public view write throw func evmCallStack_returnFromCall(
    resultCode: uint,
    returnOffset: uint,
    returnLength: uint,
    jumpTargetIfTxEnd: option<view write func()>,
) -> option<()> {
    if returnFromCallNestingDepth > 10 {
        emergencyTerminateCurrentTx();
    } else {
        returnFromCallNestingDepth = returnFromCallNestingDepth + 1;
        let _ = evmCallStack_returnFromCall_impl(resultCode, returnOffset, returnLength, jumpTargetIfTxEnd)?;
    }
    Some(())
}

view write throw func emergencyTerminateCurrentTx() {
    // there must have been an error loop exiting from a tx,
    // so issue a failure receipt for the current tx and get back to the main run loop

    debug((10001, ()));
    emitTxReceipt(
        globalCurrentTxRequest.incomingRequest,
        const::TxResultCode_unknownFailure,
        None,
        None,
        None,
        txFeeStats_zero(),
        false,    // don't emit tracing info, because we're unsure of what is going on
        globalCurrentTxRequest.originalCaller,
    );
    globalCallStack = None<EvmCallFrame>;
    emptyAvmStack();
    returnFromCallNestingDepth = 0;
    restoreAuxStackAndCall(mainRunLoop, None, true);
}

view write throw func evmCallStack_returnFromCall_impl(
    resultCode: uint,
    returnOffset: uint,
    returnLength: uint,
    jumpTargetIfTxEnd: option<view write func()>,
) -> option<()> {
    // A call just completed. Commit its effects as appropriate, and return control to its caller.

    assert((
        (resultCode == const::TxResultCode_success) || (resultCode == const::TxResultCode_revert)
                                                    || (resultCode == const::TxResultCode_executionRanOutOfGas),
        resultCode
    ));

    let (leftoverAPGas, leftoverStorageGas) = gasAccounting_pauseTxCharges();  // amount of gas lent to call that wasn't used

    let topFrame = globalCallStack?;
    let memory = topFrame.memory;
    let returnData = bytearray_extract(memory, returnOffset, returnLength);

    if let Some(newTopFrame) = topFrame.parent {
        // Returning from a non-top-level call

        topFrame = topFrame with {   // copy cached account back into callframe's main accountStore
            accountStore: accountStore_set(
                topFrame.accountStore,
                topFrame.runningAs,
                topFrame.runningAsAccount
            )
        };

        if (resultCode == const::TxResultCode_success) && !topFrame.static {
            // copy relevant data back to parent frame
            set newTopFrame.accountStore = topFrame.accountStore;
            set newTopFrame.runningAsAccount = accountStore_get(topFrame.accountStore, newTopFrame.runningAs);
            set newTopFrame.storageAllocations = topFrame.storageAllocations;
            set newTopFrame.evmLogs = topFrame.evmLogs;
            set newTopFrame.sendQueue = topFrame.sendQueue;
            set newTopFrame.selfDestructQueue = topFrame.selfDestructQueue;
        } else {
            // copy the storage allocations back to the parent frame, even though the tx didn't succeed
            //      this is needed to make gas pool tracking and receipt generation work as intended
            set newTopFrame.storageAllocations = topFrame.storageAllocations;
        }
        set newTopFrame.returnInfo = Some(
            struct {
                data: returnData,
                status: resultCode == const::TxResultCode_success,
            }
        );

        // copy returndata into caller's memory
        let resumeInfo = newTopFrame.resumeInfo?;
        if returnLength > resumeInfo.returnDataNbytes {
             returnLength = resumeInfo.returnDataNbytes;
        }
        set newTopFrame.memory = bytearray_copy(
            returnData,
            0,
            newTopFrame.memory,
            resumeInfo.returnDataOffset,
            returnLength,
        );

        evmTracer_pushReturnRevert(
            resultCode,
            returnData,
            (resumeInfo.givenAPGas - leftoverAPGas) + (resumeInfo.givenStorageGas - leftoverStorageGas),
        );

        // ready to return to caller
        // save updated EVM callstack state; send sendOnFailure message if applicable; restore caller's stack; jump to resume address
        globalCallStack = Some(newTopFrame);
        if resultCode != const::TxResultCode_success {
            if let Some(msg) = topFrame.sendOnFailure {
                // promote the send-on-failure message to the next level of the callstack
                // note that it will still be discarded if the parent (or grandparent etc) reverts
                queueMessageForSend(msg);
            }
        }
        emptyAvmStack();                            // throw away anything that callee left on the stack
        restoreAvmStack(resumeInfo.stackContents);  // restore the caller's stack
        asm(resultCode == const::TxResultCode_success) { }; // push return status onto the stack, where caller expects it to be

        // turn charging back on, with the remaining gas, including the gas that was saved when the now-returning call was made
        // if the call reverted, keep all of the storage gas, because callee's storage allocations were reverted
        let _ = gasAccounting_resumeTxCharges(
            resumeInfo.savedAPGas + leftoverAPGas,
            resumeInfo.savedStorageGas + leftoverStorageGas,
        )?;

        returnFromCallNestingDepth = 0;
        restoreAuxStackAndCall(resumeInfo.codePoint, resumeInfo.auxStackContents, false);

        evmCallStack_callHitError(8);
        //NOTREACHED
        error
    } else {
        // top-level call completed; will need to return to external caller
        // we call get/setGlobalAccountStore (without the safety checks) in here,
        //       because we want to write to the global store but we haven't yet cleared the last frame from the call stack

        if (resultCode == const::TxResultCode_success)
            && globalCurrentTxRequest.isConstructor
            && (bytearray_size(returnData) > 0)
            && (bytearray_getByte(returnData, 0) == 0xef)
        {
            // per EIP-3541, fail the transaction because the resulting account code starts with 0xef
            resultCode = const::TxResultCode_revert;
            returnData = bytearray_new(0);
        }

        if (resultCode == const::TxResultCode_success)
            && (gasAccounting_resumeTxCharges(leftoverAPGas, leftoverStorageGas) != None<()>) {
            let (entryPoint, evmJumpTable) = if globalCurrentTxRequest.isConstructor {
                // the call was a constructor, so we need to install the resulting EVM code as the new contract's deploy code
                let (uAcctStore, ep, ejt, created) = accountStore_createOrAddCodeRef(
                    topFrame.accountStore,
                    const::ContractStateVersion_current,
                    returnData
                )?;
                globalCallStack = Some(topFrame with { accountStore: uAcctStore });
                if created {
                    evmCallStack_addStorageCharge( (bytearray_size(returnData) + 31) / 32, None);
                }
                topFrame = globalCallStack?;
                (ep, ejt)
            } else {
                (errorHandler, newmap<uint, func()>)   // these won't be used
            };

            let (completed, gasUsage, feeStats, deferredPayments) = gasAccounting_endTxCharges(
                topFrame.storageAllocations,
                globalCurrentTxRequest.feeStats,
                Some(accountStore_set(topFrame.accountStore, topFrame.runningAs, topFrame.runningAsAccount)),
            )?;

            if completed {
                if globalCurrentTxRequest.isConstructor {
                    // Constructor call was successful, so finish setting up the account.

                    // Use the storage left over by the constructor.
                    let storageMap = if let Some(sm) = account_getAllStorage(topFrame.runningAsAccount) {
                        sm
                    } else {
                        // Somehow the constructor didn't have storage; report error and recover.
                        evmTracer_pushReturnRevert(const::TxResultCode_formatError, bytearray_new(0), gasUsage.gasUsed);
                        emitTxReceipt(
                            globalCurrentTxRequest.incomingRequest,
                            const::TxResultCode_formatError,
                            None,
                            None,
                            Some(gasUsage),
                            feeStats,
                            true,
                            globalCurrentTxRequest.originalCaller,
                        );
                        evmCallStack_callHitError(5);
                        //NOTREACHED
                        error
                    };

                    // Update the global account store
                    let acctStore = accountStore_set(
                        topFrame.accountStore,
                        topFrame.runningAs,
                        account_setContractInfo(
                            topFrame.runningAsAccount,
                            returnData,
                            evmJumpTable,
                            entryPoint,
                            storageMap,
                            true,
                        )
                    );
                    if let Some(uas) = deferredPayments_apply(acctStore, deferredPayments) {
                        acctStore = uas;
                    }
                    // Commit the self-destruct events that were requested during the call.
                    let sdq = topFrame.selfDestructQueue;
                    while ! queue_isEmpty(sdq) {
                        let (q, item) = queue_get(sdq)?;
                        sdq = q;
                        let victim = unsafecast<address>(item);
                        acctStore = accountStore_destroyAccount(acctStore, victim);
                    }
                    setGlobalAccountStore(acctStore);

                    returnData = bytearray_set256(
                        bytearray_new(0),
                        0,
                        uint(topFrame.runningAs)
                    );

                    evmTracer_pushReturnRevert(
                        const::TxResultCode_success,
                        returnData,
                        gasUsage.gasUsed,
                    );

                    // emit queued sends
                    let updatedEvmLogs = sendQueuedMessages(topFrame.sendQueue, topFrame.evmLogs);

                    // Emit log item reporting success
                    emitTxReceipt(
                        globalCurrentTxRequest.incomingRequest,
                        const::TxResultCode_success,
                        Some(returnData),
                        Some(updatedEvmLogs),
                        Some(gasUsage),
                        feeStats,
                        true,
                        globalCurrentTxRequest.originalCaller,
                    );

                    // increment global contract count
                    setGlobalAccountStore(accountStore_changeNumContracts(getGlobalAccountStore(), int(1)));
                } else {
                    let updatedEvmLogs = if ! globalCurrentTxRequest.nonMutating {
                        // It was a successful non-constructor tx (not a non-mutating call).
                        // We'll commit the results of the tx

                        if let Some(reqAndLogs) = globalCurrentRetryableRequest {
                            // This is an "outer" tx that redeemed an "inner" retryable

                            // emit receipt for the inner tx
                            emitTxReceipt(
                                reqAndLogs.req,
                                const::TxResultCode_success,
                                Some(returnData),
                                Some(reqAndLogs.evmLogs),
                                None,
                                txFeeStats_zero(),
                                false,
                                globalCurrentTxRequest.originalCaller,
                            );
                            returnData = bytearray_new(0);   // outer tx should have no returndata
                            globalCurrentRetryableRequest = None<IncomingRequestAndLogs>;
                        }

                        // Save cached account back to main accountStore
                        let acctStore = accountStore_set(
                            topFrame.accountStore,
                            topFrame.runningAs,
                            topFrame.runningAsAccount
                        );

                        // Finish the self-destruct events that were requested during the call.
                        let sdq = topFrame.selfDestructQueue;
                        while ! queue_isEmpty(sdq) {
                            let (q, item) = queue_get(sdq)?;
                            sdq = q;
                            let victim = unsafecast<address>(item);
                            acctStore = accountStore_destroyAccount(acctStore, victim);
                        }

                        // emit queued sends
                        let updEvmLogs = sendQueuedMessages(topFrame.sendQueue, topFrame.evmLogs);

                        // Save results back to the main globalAccountStore
                        if let Some(uas) = deferredPayments_apply(acctStore, deferredPayments) {
                            acctStore = uas;
                        }
                        setGlobalAccountStore(acctStore);

                        updEvmLogs
                    } else {
                        // call was non-mutating, so don't commit any state
                        topFrame.evmLogs
                    };

                    evmTracer_pushReturnRevert(
                        const::TxResultCode_success,
                        returnData,
                        gasUsage.gasUsed,
                    );

                    // Emit a log item reporting success
                    emitTxReceipt(
                        globalCurrentTxRequest.incomingRequest,
                        const::TxResultCode_success,
                        Some(returnData),
                        Some(updatedEvmLogs),
                        Some(gasUsage),
                        feeStats,
                        true,
                        globalCurrentTxRequest.originalCaller,
                    );
                }
            } else {
                if resultCode == const::TxResultCode_success {
                    resultCode = const::TxResultCode_executionRanOutOfGas;
                }
                evmTracer_pushReturnRevert(
                    resultCode,
                    returnData,
                    gasUsage.gasUsed,
                );
                // Emit a log item reporting failure
                emitTxReceipt(
                    globalCurrentTxRequest.incomingRequest,
                    resultCode,
                    None,
                    None,
                    Some(gasUsage),
                    feeStats,
                    true,
                    globalCurrentTxRequest.originalCaller,
                );
                if let Some(uas) = deferredPayments_apply(getGlobalAccountStore(), deferredPayments) {
                    setGlobalAccountStore(uas);
                }
            }
        } else {
            // Request failed

            if gasAccounting_resumeTxCharges(leftoverAPGas, leftoverStorageGas) == None<()> {
                resultCode = const::TxResultCode_executionRanOutOfGas;
                // even though we didn't succeed in switching back to charging the tx for gas,
                //     gasAccounting_endTxCharges will do the right thing because it will act as if user had zero gas left
            }
            let (_, gasUsage, feeStats, payments) = gasAccounting_endTxCharges(
                topFrame.storageAllocations,
                globalCurrentTxRequest.feeStats,
                Some(getGlobalAccountStore()),   // base refunds on pre-tx state because we are reverting any changes
            )?;
            if let Some(uas) = deferredPayments_apply(getGlobalAccountStore(), payments) {
                setGlobalAccountStore(uas);
            }
            if let Some(msg) = topFrame.sendOnFailure {
                outbox_append(msg);
            }
            evmTracer_pushReturnRevert(resultCode, returnData, gasUsage.gasUsed);
            emitTxReceipt(
                globalCurrentTxRequest.incomingRequest,
                resultCode,
                Some(returnData),
                None,
                Some(gasUsage),
                feeStats,
                true,
                globalCurrentTxRequest.originalCaller,
            );
        }

        // Now discard any EVM and AVM stack contents and jump back to the main run loop.
        globalCallStack = None<EvmCallFrame>;
        emptyAvmStack();
        returnFromCallNestingDepth = 0;
        restoreAuxStackAndCall(
            if let Some(target) = jumpTargetIfTxEnd { target } else { mainRunLoop },
            None,
            true
        );  // should never return
        evmCallStack_callHitError(9);
        //NOTREACHED
        error
    }
}

public view write throw func evmCallStack_callRetryableTxAndReturn(rtx: RetryableTx) -> (bool, ByteArray) {
    if let Some(topFrame) = globalCallStack {
        // The retryable call should see itself as having been called by the original caller.
        // So we save parts of the callframe, then overwrite them before making the call,
        //     in order to impersonate the original caller.
        let savedRunningAs = topFrame.runningAs;
        let savedMemory = topFrame.memory;
        let savedEvmLogs = topFrame.evmLogs;

        let theFrame = evmCallFrame_setRunningAsAddress(topFrame, rtx.sender);
        set theFrame.memory = rtx.calldata;
        set theFrame.evmLogs = evmlogs_empty();
        globalCallStack = Some(theFrame);

        globalCurrentRetryableRequest = Some(struct {
            req: rtx.l1Message with {
                arbBlockNumber: inbox_currentArbBlockNumber()
            } with {
                ethBlockNumber: inbox_currentEthBlockNumber()
            } with {
                timestamp: inbox_currentTimestamp()
            },
            evmLogs: evmlogs_empty(),
            originalSender: retryableTx_getOriginalSender(rtx),
        });

        let retCode = evmOp_callAndReturn(
            chainParams_getOrDie(const::Atom_Param_TxGasLimit),    // give all of our gas to the callee
            rtx.destination,
            rtx.callvalue,
            0,
            bytearray_size(rtx.calldata),
            0,
            0,
            false,
            Some(rtx.callvalueEscrowKey),
            None,
        );
        // now we have returned from the call

        if let Some(newTopFrame) = globalCallStack {
            // save evm logs to emit in the inner tx's receipt
            if let Some(retryableReq) = globalCurrentRetryableRequest {
                set retryableReq.evmLogs = newTopFrame.evmLogs;
                globalCurrentRetryableRequest = Some(retryableReq);
            }

            // restore saved callframe info
            set newTopFrame.memory = savedMemory;
            set newTopFrame.evmLogs = savedEvmLogs;
            newTopFrame = evmCallFrame_setRunningAsAddress(newTopFrame, savedRunningAs);
            globalCallStack = Some(newTopFrame);
            (retCode, if let Some(retInfo) = newTopFrame.returnInfo { retInfo.data } else { bytearray_new(0) })
        } else {
            // this shouldn't happen
            (false, bytearray_new(0))
        }
    } else {
        // this shouldn't happen
        (false, bytearray_new(0))
    }
}

func ethTransferOrGrant(
    acctStore: AccountStore,
    payer: address,
    recipient: address,
    amount: uint,
    callvalueEscrowKey: option<uint>,
) -> option<AccountStore> {
    if let Some(escrowKey) = callvalueEscrowKey {
        accountStore_payFromEscrow(acctStore, escrowKey, recipient, amount)
    } else {
        accountStore_transferEthBalance(acctStore, payer, recipient, amount)
    }
}

sensitive func saveAvmStack() -> Stack {
    // pop all items from the AVM stack, push them into a Stack
    let ret = stack_new();
    while ! asm() bool { stackempty } {
        let stackTop = asm() any { };  // pop a value from the AVM stack
        ret = stack_push(ret, stackTop);
    }
    ret
}

public sensitive func emptyAvmStack() {
    // discard everything on the AVM stack
    while ! asm() bool { stackempty }  {
        asm() { pop }; // pop a value from AVM stack and discard it
    }
}

sensitive func restoreAvmStack(savedStack: Stack) {
    // restore AVM stack state, from a Stack that was created earlier by saveAvmStack
    while ! stack_isEmpty(savedStack) {
        if let Some(res) = stack_pop(savedStack) {
            let (*savedStack, top) = res;
            asm (top) { };  // push top onto the AVM stack
        }
    }
}

public sensitive view write throw func snapshotAuxStack() -> Stack {
    // Save a copy of everything from the auxstack, except the current callframe and return address (which are on top).
    // Keep the current callframe on top of the auxstack (except during asm blocks)
    //       because the compiler probably wants to use the callframe
    let ret = stack_new();
    while ! asm() bool { auxpop auxstackempty swap1 auxpush } {  // check if there is more than one item on the auxstck
        ret = stack_push(
            ret,
            asm() any {    // discard the second item from the auxstack, leaving the top item unmodified
                auxpop
                auxpop
                swap1
                auxpush
            }
        );
    }

    // Now restore everything that we popped from the aux stack, so the aux stack ends up exactly as it started.
    let savedAuxStack = ret;
    while ! stack_isEmpty(savedAuxStack) {
        if let Some(res) = stack_pop(savedAuxStack) {
            let (*savedAuxStack, val) = res;
            asm(val) {
                auxpop
                swap1
                auxpush
                auxpush
            };
        } else {
            // can't happen, because we just verified that stack isn't empty
            evmCallStack_callHitError(19);  // shouldn't ever return
        }
    }

    // discard the first item saved to the saved aux stack, because it is this function's return address
    stack_discardDeepestItems(ret, 1)
}

public view write throw func cleanAvmAuxStackAndCall(funcToCall: view write func(), pushFakeReturnAddress: bool) {
    restoreAuxStackAndCall(funcToCall, None, pushFakeReturnAddress);
}

public sensitive view write throw func restoreAuxStackAndCall(
    funcToCall: view write func(),
    maybeSavedAuxStack: option<Stack>,
    pushFakeReturnAddress: bool
) {
    // This restores a saved version of the AvmAuxStack, then calls funcToCall.
    // funcToCall must never try to return.

    // Discard everything from the auxstack, except the current callframe (which is on top).
    // Keep the callframe on top of the auxstack (except during asm blocks)
    //       because the compiler probably wants to use the callframe
    while ! asm() bool { auxpop auxstackempty swap1 auxpush } {   // check if there is more than one item on the auxstack
        asm() {     // discard the second item on the auxstack, leaving the top item unmodified
            auxpop
            auxpop
            pop
            auxpush
        };
    }

    if let Some(savedAuxStack) = maybeSavedAuxStack {
        // Restore the saved AuxStack, leaving only the current callframe on top.
        // Keep the callframe on top of the auxstack (except during asm blocks)
        while ! stack_isEmpty(savedAuxStack) {
            if let Some(res) = stack_pop(savedAuxStack) {
                let (*savedAuxStack, val) = res;
                asm(val) {
                    auxpop
                    swap1
                    auxpush
                    auxpush
                };
            } else {
                // can't happen, because we just verified that stack isn't empty
                evmCallStack_callHitError(19);  // shouldn't ever return
            }
        }
    }

    // Discard our callframe, push a fake return address, and jump to funcToCall
    // funcToCall will think somebody called it normally, with the restored auxstack
    if pushFakeReturnAddress {
        asm(funcToCall) {
            auxpop
            pop
            [0] swap1  // bogus return address, which funcToCall will save in its callframe but will never use
            jump
        };
    } else {
        asm(funcToCall) {
            auxpop
            pop
            jump
        };
    }
}

public view func evmCallStack_topFrame() -> option<EvmCallFrame> {
    globalCallStack
}

public view func evmCallStack_oldestCallFrame() -> option<EvmCallFrame> {
    let frame = globalCallStack?;
    loop {
        if let Some(parent) = frame.parent {
            frame = parent;
        } else {
            return Some(frame);
        }
    }
}

public func evmCallFrame_constructorIsOnStackForAddress(frame: EvmCallFrame, addr: address) -> bool {
    loop {
        if (frame.isConstructor) && (frame.runningAs == addr) {
            return true;
        }
        if let Some(parent) = frame.parent {
            frame = parent;
        } else {
            return false;
        }
    }
}

public view write throw func evmCallStack_touchMemoryOffset(offset: uint) {
    if let Some(topFrame) = globalCallStack {
        let prev = topFrame.maxMemoryOffsetTouched;
        if offset > prev {
            let delta =   (safeMul(offset, offset) / const::Charging_MemoryChargeDenominator)
                        - (safeMul(prev, prev) / const::Charging_MemoryChargeDenominator);
            globalCallStack = Some(topFrame with { maxMemoryOffsetTouched: offset });

            // deduct the gas difference from current gas remaining, but add it back to the gas pool because it's not computation
            let gasFactor = chainParams_getOrDie(const::Atom_Param_AvmGasPerArbGas);
            let gas = getGas() / gasFactor;
            if delta < gas {
                gasAccounting_addToGasPool(delta);
                setGas(gasFactor * (gas - delta));
            } else {
                gasAccounting_addToGasPool(gas);
                setGas(1);      // ensure we'll run out of gas immediately
            }
        }
    }
}

public view func evmCallStack_runningCodeFromAccount() -> option<Account> {
    Some(evmCallFrame_runningCodeFromAccount(globalCallStack?))
}

public view write func evmCallStack_changeRunningAs(newRunningAsAddr: address) -> option<()> {
    let topFrame = globalCallStack?;
    set topFrame.accountStore = accountStore_set(
        topFrame.accountStore,
        topFrame.runningAs,
        topFrame.runningAsAccount,
    );
    set topFrame.runningAs = newRunningAsAddr;
    set topFrame.runningAsAccount = accountStore_get(topFrame.accountStore, topFrame.runningAs);
    globalCallStack = Some(topFrame);
    Some(())
}

public view func evmCallStack_getTopFrameReturnData() -> option<ByteArray> {
    Some(((globalCallStack?).returnInfo?).data)
}

public view func evmCallStack_getAccount(addr: address) -> option<Account> {
    let topFrame = globalCallStack?;
    Some(if topFrame.runningAs == addr {
        topFrame.runningAsAccount
    } else {
        accountStore_get(topFrame.accountStore, addr)
    })
}

public view write func evmCallStack_setAccount(addr: address, acct: Account) -> bool {
    if let Some(topFrame) = globalCallStack {
        if topFrame.runningAs == addr {
            set topFrame.runningAsAccount = acct;
        } else {
            set topFrame.accountStore = accountStore_set(topFrame.accountStore, addr, acct);
        }
        globalCallStack = Some(topFrame);
        true
    } else {
        false
    }
}

public view write throw func evmCallStack_getAccountInCurrentContext(addr: address) -> Account {
    accountStore_get(evmCallStack_getAccountStoreInCurrentContext(), addr)
}

public view write throw func evmCallStack_setAccountInCurrentContext(addr: address, acct: Account) {
    if ! evmCallStack_setAccount(addr, acct) {
        safeSetGlobalAccountStore(
            accountStore_set(
                safeGetGlobalAccountStore(),
                addr,
                acct,
            )
        );
    }
}

public view write throw func evmCallStack_getAccountStoreInCurrentContext() -> AccountStore {
    if let Some(topFrame) = globalCallStack {
        accountStore_set(topFrame.accountStore, topFrame.runningAs, topFrame.runningAsAccount)
    } else {
        safeGetGlobalAccountStore()
    }
}

public view write throw func evmCallStack_setAccountStoreInCurrentContext(acctStore: AccountStore) {
    if let Some(topFrame) = globalCallStack {
        set topFrame.accountStore = acctStore;
        set topFrame.runningAsAccount = accountStore_get(acctStore, topFrame.runningAs);
        globalCallStack = Some(topFrame);
    } else {
        safeSetGlobalAccountStore(acctStore);
    }
}

public view write throw func _evmCallStack_transferEthInCurrentContext(from: address, to: address, amount: uint) -> option<()> {
    if let Some(topFrame) = globalCallStack {
        globalCallStack = Some(evmCallFrame_transferEth(topFrame, from, to, amount)?);
    } else {
        safeSetGlobalAccountStore(accountStore_transferEthBalance(safeGetGlobalAccountStore(), from, to, amount)?);
    }
    Some(())
}

public view func evmCallStack_getRealCallerInfo(levelsToSubtract: uint) -> option<(address, bool)> {
    // ignoring the top <levelsToSubtract> levels of the EVM call stack,
    //     return (the sender's address without L1 contract address aliasing applied, whether it was aliased

    let stackDepth = evmCallStack_stackDepth();
    if stackDepth == 1+levelsToSubtract {
        // top-level call from L1
        return Some((
            globalCurrentTxRequest.originalCaller,
            (globalCurrentTxRequest.caller != globalCurrentTxRequest.originalCaller)
        ));
    } else if stackDepth == 2+levelsToSubtract {
        if let Some(gcrr) = globalCurrentRetryableRequest {
            return Some((gcrr.originalSender, (gcrr.req.sender != gcrr.originalSender)));
        }
    }

    let frame = globalCallStack?;
    while levelsToSubtract > 0 {
        frame = frame.parent?;
        levelsToSubtract = levelsToSubtract - 1;
    }
    Some((frame.caller, false))
}

public view write func evmCallStack_changeNumAccounts(delta: int) {
    if let Some(topFrame) = globalCallStack {
        set topFrame.accountStore = accountStore_changeNumContracts(topFrame.accountStore, delta);
        globalCallStack = Some(topFrame);
    }
    // if not in a stack frame (which shouldn't happen), ignore the problem, the only consequence is inaccurate stats
}

public view write throw func evmCallStack_getTopFrameMemoryOrDie() -> ByteArray {
    if let Some(topFrame) = globalCallStack {
        topFrame.memory
    } else {
        evmCallStack_callHitError(10);
        error
    }
}

public view write throw func evmCallStack_setTopFrameMemory(mem: ByteArray) -> bool {
    evmCallStack_touchMemoryOffset(bytearray_size(mem));
    if let Some(topFrame) = globalCallStack {
        set topFrame.memory = mem;
        globalCallStack = Some(topFrame);
        true
    } else {
        false
    }
}

public view write throw func evmCallStack_queueMessage(msg: any) {
    if let Some(topFrame) = globalCallStack {
        set topFrame.sendQueue = queue_put(topFrame.sendQueue, msg);
        globalCallStack = Some(topFrame);
        return;
    }

    evmCallStack_callHitError(14);
}

public view write func evmCallStack_transferEthFromCurrent(
    dest: address,
    amount: uint,
) -> option<()> {
    let topFrame = globalCallStack?;
    globalCallStack = Some(evmCallFrame_transferEth(topFrame, topFrame.runningAs, dest, amount)?);
    Some(())
}

public view write func evmCallStack_transferEthFromEscrow(escrowKey: uint, to: address, amount: uint) -> option<()> {
    let topFrame = globalCallStack?;
    if to == topFrame.runningAs {
        let acctStore = accountStore_set(topFrame.accountStore, topFrame.runningAs, topFrame.runningAsAccount);
        acctStore = accountStore_payFromEscrow(acctStore, escrowKey, to, amount)?;
        set topFrame.accountStore = acctStore;
        set topFrame.runningAsAccount = accountStore_get(acctStore, topFrame.runningAs);
    } else {
        set topFrame.accountStore = accountStore_payFromEscrow(topFrame.accountStore, escrowKey, to, amount)?;
    }
    globalCallStack = Some(topFrame);
    Some(())
}


public view write throw func evmCallStack_setTopFrameStorageCell(offset: uint, value: uint) -> option<()> {
    let topFrame = globalCallStack?;
    let storageSizeBefore = account_getStorageSize(topFrame.runningAsAccount)?;
    let runningAsAccount = account_setStorageCell(
        topFrame.runningAsAccount,
        offset,
        value
    )?;
    let storageSizeAfter = account_getStorageSize(runningAsAccount)?;
    set topFrame.runningAsAccount = runningAsAccount;
    globalCallStack = Some(topFrame);
    if storageSizeAfter > storageSizeBefore {
        evmCallStack_addStorageCharge(storageSizeAfter - storageSizeBefore, Some((topFrame.runningAs, offset)));
    }
    Some(())
}

public view write func evmCallStack_addEvmLogToCurrent(item: any) -> option<()> {
    let topFrame = globalCallStack?;
    item = asm(0, item, topFrame.runningAs) any { tset };
    set topFrame.evmLogs = evmlogs_appendAny(topFrame.evmLogs, item);
    globalCallStack = Some(topFrame);
    Some(())
}

public view write throw func evmCallStack_selfDestructCurrentAccount(recipient: address) {
    if let Some(topFrame) = globalCallStack {
        let destructee = topFrame.runningAs;
        let amount = account_getBalance(topFrame.runningAsAccount);
        if amount > 0 {
            // give amount to the correct party, according to the yellow paper's rules
            if recipient == destructee {
                // yellow paper says to burn the funds; we'll give them to the chain's reserve fund
                recipient = getAddressForReserveFundsDeposit();
            }
            topFrame = if let Some(tf) = evmCallFrame_transferEth(topFrame, destructee, recipient, amount) {
                tf
            } else {
                evmCallStack_callHitError(30);
                //NOTREACHED
                topFrame
            };
        }

        set topFrame.selfDestructQueue = queue_put(topFrame.selfDestructQueue, destructee);
        globalCallStack = Some(topFrame);
    }
}

public func evmCallFrame_runningAsAddress(frame: EvmCallFrame) -> address {
    frame.runningAs
}

public func evmCallFrame_setRunningAsAddress(frame: EvmCallFrame, addr: address) -> EvmCallFrame {
    let acctStore = accountStore_set(frame.accountStore, frame.runningAs, frame.runningAsAccount);
    set frame.runningAs = addr;
    set frame.runningAsAccount = accountStore_get(acctStore, addr);
    set frame.accountStore = acctStore;
    frame
}

public func evmCallFrame_runningAsAccount(frame: EvmCallFrame) -> Account {
    frame.runningAsAccount
}

public func evmCallFrame_runningCodeFromAccount(frame: EvmCallFrame) -> Account {
    evmCallFrame_getAccount(frame, frame.runningCodeFrom)
}

public func evmCallFrame_getCaller(frame: EvmCallFrame) -> address {
    frame.caller
}

public func evmCallFrame_getAccount(frame: EvmCallFrame, addr: address) -> Account {
    if addr == frame.runningAs {
        frame.runningAsAccount
    } else {
        accountStore_get(frame.accountStore, addr)
    }
}

public func evmCallFrame_transferEth(frame: EvmCallFrame, from: address, to: address, amount: uint) -> option<EvmCallFrame> {
    if (from == frame.runningAs) || (to == frame.runningAs) {
        // runningAs account is involved, so we need to save and restore the cached copy of it
        let acctStore = accountStore_set(frame.accountStore, frame.runningAs, frame.runningAsAccount);
        acctStore = accountStore_transferEthBalance(acctStore, from, to, amount)?;
        set frame.accountStore = acctStore;
        set frame.runningAsAccount = accountStore_get(acctStore, frame.runningAs);
    } else {
        set frame.accountStore = accountStore_transferEthBalance(frame.accountStore, from, to, amount)?;
    }
    Some(frame)
}

public func evmCallFrame_getMemory(frame: EvmCallFrame) -> ByteArray {
    frame.memory
}

public func evmCallFrame_getCallvalue(frame: EvmCallFrame) -> uint {
    frame.callvalue
}

public func evmCallFrame_getCalldata(frame: EvmCallFrame) -> ByteArray {
    frame.calldata
}

public func evmCallFrame_shouldRevertOnStorageWrite(frame: EvmCallFrame) -> bool {
    frame.revertOnStorageWrite
}

public func _evmCallFrame_getEvmLogs(frame: EvmCallFrame) -> EvmLogs {
    frame.evmLogs
}

public func _evmCallFrame_getResumeCodePoint(frame: EvmCallFrame) -> option<func()> {
    Some((frame.resumeInfo?).codePoint)
}

public func _evmCallFrame_getSelfDestructQueue(frame: EvmCallFrame) -> Queue {
    frame.selfDestructQueue
}

public func _evmCallFrame_getParent(frame: EvmCallFrame) -> option<EvmCallFrame> {
    frame.parent
}

public func evmCallFrame_getReservedStorageGas(frame: EvmCallFrame) -> uint {
    if let Some(resumeInfo) = frame.resumeInfo {
        resumeInfo.savedStorageGas
    } else {
        0
    }
}

public view write throw func evmCallStack_callHitError(errInfo: any) {
    debug((664, errInfo));
    if evmCallStack_returnFromCall(const::TxResultCode_revert, 0, 0, None) == None<()> {
        // something has gone seriously wrong with the evmCallStack
        // recover by clearing the evmCallStack, refunding unused gas, and jumping to the error handler
        globalCallStack = None;
        let _ = gasAccounting_endTxCharges(0, txFeeStats_zero(), None);

        errorHandler();
        //NOTREACHED
        error;
    }
}

func _getLastFrame(topFrame: EvmCallFrame) -> EvmCallFrame {
    loop {
        if let Some(tf) = topFrame.parent {
            topFrame = tf;
        } else {
            return topFrame;
        }
    }
}
